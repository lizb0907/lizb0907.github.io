---
layout: post
title: Jvm实战、调优记录
categories: Jvm
description: 记录JVM相关，调优实践
keywords: JVM, GC，调优
---

jvm性能调优学习积累

**目录**

* TOC
{:toc}

## 为什么学习jvm?

java把内存管理交给了jvm,虽然给我们带来了很大的遍历，但任何事情都有两面性。

如果你不了解jvm干了什么，当发生内存泄漏怎么办？

## 简单认识jvm运行时数据区

![](/images/posts/jvm/5.png)

```sh
一般我们写代码，就是写数据、指令、控制。
数据：类里的成员变量
指令：int a = 10
控制： return
```

### 1.程序计数器（线程私有）

![](/images/posts/jvm/6.png)

指向当前线程正在执行的字节码指令的地址 行号

既然当前线程正在执行，那为什么还要找个地方还要记录一下？是多余操作？

```sh
线程在cpu上执行，cpu在执行时是用时间片，时间片是抢占式的。线程是可以被挂起的，

当前的指令不一定就一定是一次性运行完的，所以需要找个地方把指令存起来。

每个线程都有一个自己的程序计数器。
```

### 2.虚拟机栈（线程私有）

![](/images/posts/jvm/7.png)

存储当前线程运行方法所需要的数据、指令、返回地址。

注意是方法，线程私有，当一个方法运行的时候，就会压到虚拟机栈。

栈帧：
```sh
方法运行时的基础数据结构，每个方法运行时都会创建一个栈帧。通俗的个人理解，
可以认为栈帧就是栈里的一个元素，当前栈帧就是顶部的要出栈的元素，这个元素是一个数据
结构，存储局部变量表，操作数栈，动态链接，出口等信息。
```

#### 1.一个方法里是不是只压入一个栈？

不一定，如果方法里又调用方法，那么压入多个栈。

#### 2.一个栈帧里面存储很多东西，重点关注如下

##### 1.局部变量表
```sh
private Object obj = new Object();

public void print()
{
    int a = 10;
    int sum = a + 10;

    Object object = obj; 

    return;

    //todo 
}
```
局部变量存的就是，局部变量，编译期可知。包括基本数据类型和对象引用，

例如：int a = 10 ，Object object = obj;     

long 和 double类型数据占用2个局部变量空间（Slot）,其余的数据类型只占用1个。

局部变量表所需内存空间在编译期间完成分配，当进入一个方法时，大小已经确定，不会在方法运行期间改变。

##### 2.操作数栈

方法里，做一些算术是在操作数栈里进行的。例如上面的 int sum = a + 10;

可以对class进行反编译，然后查看指令验证。

##### 3.动态链接

每个栈栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。

运行时常量池翻译的不好，其实是字面量，里面存的不仅是常量。

运行时常量池用于存放编译期生成的各种字面量和符号引用。例如：类里面引用到了另一个类，那么就要记录。

```java
/**
* 只是存了符合引用
*/
private static Student student;

public static void main(String[] args) {
    //实际运行时指向真正的引用地址
    student.getName();
    student.getAge();
}
```

##### 4.方法出口

方法执行完后，要出栈，出栈后去哪里。

### 3.本地方法栈（线程私有）

基本和虚拟机栈一致，只是本地方法栈为虚拟机使用到的Native()方法服务。


### 4.方法区（线程共享）

```java
public class StaticInit
{
   //常量
    public static final int DEFAULT_AGE = 10;
    public static final String NAME = "标z仔";
    //静态变量
    private static int k = 0;
    //成员变量
    private int a = 1;
}
```
1.方法区也有人叫它“永久代”。jdk1.8之前java内存模型有永久代概念，永久代在方法区。

2.在HotSpot JVM中，只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。

3.方法区用于存放类信息、常量、静态变量、JIT(动态编译)及时编译后的代码等数据。

4.jdk1.7的HotSpot,已经把原本放在永久代的字符串常量池、静态变量等移出。

5.jdk1.8
```sh
1.jdk1.8完全废弃了永久代概念，改用本地内存中实现的元空间。
2.取消永久代，方法区存放于元空间(Metaspace)。
3.元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中 ，但是实际上我们说的堆指的是用于存放java对象的那些空间。
4.元空间并不在虚拟机中,而是使用本地内存。
```

6.为什么jdk1.8要把方法区从JVM里移到直接内存？
```sh
1.永久代有-XX：MaxPermSize上限，容易遇到内存溢出。而元空间使用的是直接内存，受本机可用内存的限制，只要没有触碰到进程可用的内存上限理论上就不会有问题。

2.直接内存，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先复制到直接内存，再利用本地IO处理。
```
#### 运行时常量池，字符池常量池

### 5.堆（线程共享）

![](/images/posts/jvm/8.png)
从图可以看出，

1.虚拟机启动时创建。

2.所有对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术
逐渐成熟，所有对象都分配在堆上分配也渐渐变得不是那么那么“绝对”了。

3.垃圾收集采用分代，所以细分可以新生代，老年代，永久代（1.8为元空间）。

4.物理上可以不连续，逻辑上连续即可。

## 工作中调优实践

### 1.我们项目v2版本中jvm参数（未优化）

-Server启动     

-Xms 初始堆大小

-Xmx 最大堆内存

-Xss 设置每个线程的堆栈大小

-XX:MetaspaceSize ：
JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区
别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本
地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值
进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过
MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-verbose:gc
Java -verbose:gc 中参数-verbose:gc 表示输出虚拟机中GC的详细情况.

-Xloggc:gc.log
-Xloggc:../logs/gc.log 日志文件的输出路径

-XX:+PrintGCDateStamps 
GC发生的时间信息

-XX:+PrintGCDetails
打印GC详细信息
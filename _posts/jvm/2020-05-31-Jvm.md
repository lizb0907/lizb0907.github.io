---
layout: post
title: Jvm实战、调优记录
categories: Jvm
description: 记录JVM相关，调优实践
keywords: JVM, GC，调优
---

jvm性能调优学习积累

**目录**

* TOC
{:toc}

## 为什么学习jvm?

java把内存管理交给了jvm,虽然给我们带来了很大的遍历，但任何事情都有两面性。

如果你不了解jvm干了什么，当发生内存泄漏怎么办？

## jvm运行时数据区

![](/images/posts/jvm/5.png)


一般我们写代码，就是写数据、指令、控制。

数据：类里的成员变量

指令：int a = 10

控制： return

### 1.程序计数器（线程私有）

![](/images/posts/jvm/6.png)

指向当前线程正在执行的字节码指令的地址 行号

既然当前线程正在执行，那为什么还要找个地方还要记录一下？是多余操作？

```sh
线程在cpu上执行，cpu在执行时是用时间片，时间片是抢占式的。线程是可以被挂起的，

当前的指令不一定就一定是一次性运行完的，所以需要找个地方把指令存起来。

每个线程都有一个自己的程序计数器。
```

### 2.虚拟机栈（线程私有）

存储当前线程运行方法所需要的数据、指令、返回地址

## 工作中调优实践

### 1.我们项目v2版本中jvm参数（未优化）

-Server启动     

-Xms 初始堆大小

-Xmx 最大堆内存

-Xss 设置每个线程的堆栈大小

-XX:MetaspaceSize ：
JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区
别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本
地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值
进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过
MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-verbose:gc
Java -verbose:gc 中参数-verbose:gc 表示输出虚拟机中GC的详细情况.

-Xloggc:gc.log
-Xloggc:../logs/gc.log 日志文件的输出路径

-XX:+PrintGCDateStamps 
GC发生的时间信息

-XX:+PrintGCDetails
打印GC详细信息
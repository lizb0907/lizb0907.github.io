---
layout: post
title: Jvm实战、调优记录
categories: Jvm
description: 记录JVM相关，调优实践
keywords: JVM, GC，调优
---

jvm性能调优学习积累

**目录**

* TOC
{:toc}

## 为什么学习jvm?

java把内存管理交给了jvm,虽然给我们带来了很大的遍历，但任何事情都有两面性。

如果你不了解jvm干了什么，当发生内存泄漏怎么办？

## jvm运行时数据区

![](/images/posts/jvm/5.png)

```sh
一般我们写代码，就是写数据、指令、控制。
数据：类里的成员变量
指令：int a = 10
控制： return
```

### 1.程序计数器（线程私有）

![](/images/posts/jvm/6.png)

指向当前线程正在执行的字节码指令的地址 行号

既然当前线程正在执行，那为什么还要找个地方还要记录一下？是多余操作？

```sh
线程在cpu上执行，cpu在执行时是用时间片，时间片是抢占式的。线程是可以被挂起的，

当前的指令不一定就一定是一次性运行完的，所以需要找个地方把指令存起来。

每个线程都有一个自己的程序计数器。
```

### 2.虚拟机栈（线程私有）

存储当前线程运行方法 所需要的数据、指令、返回地址。

当一个方法运行的时候，就会压到虚拟机栈。

栈帧：
```sh
方法运行时的基础数据结构，每个方法运行时都会创建一个栈帧。通俗的个人理解，
可以认为栈帧就是栈里的一个元素，当前栈帧就是顶部的要出栈的元素，这个元素是一个数据
结构，存储局部变量表，操作数栈，动态链接，出口等信息。
```

#### 1.一个方法里是不是只压入一个栈？

不一定，如果放方法里又调用方法，那么压入多个栈。

#### 2.虚拟机栈里面存储很多东西，重点关注如下

##### 1.局部变量表
```sh
private Object obj = new Object();

public void print()
{
    int a = 10;
    int sum = a + 10;

    Object object = obj; 

    return;

    //todo 
}
```
局部变量存的就是，局部变量。例如：int a = 10 

##### 2.操作数栈

##### 3.动态链接

4.出口

## 工作中调优实践

### 1.我们项目v2版本中jvm参数（未优化）

-Server启动     

-Xms 初始堆大小

-Xmx 最大堆内存

-Xss 设置每个线程的堆栈大小

-XX:MetaspaceSize ：
JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区
别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本
地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值
进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过
MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-verbose:gc
Java -verbose:gc 中参数-verbose:gc 表示输出虚拟机中GC的详细情况.

-Xloggc:gc.log
-Xloggc:../logs/gc.log 日志文件的输出路径

-XX:+PrintGCDateStamps 
GC发生的时间信息

-XX:+PrintGCDetails
打印GC详细信息
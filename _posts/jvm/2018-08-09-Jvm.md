---
layout: post
title: Jvm实战、调优记录
categories: Jvm
description: 记录JVM相关，调优实践
keywords: JVM, GC，调优
---

java垃圾收集基础知识（oracle官方文档）,总结深入理解java虚拟机



**目录**

* TOC
{:toc}

## java垃圾收集基础知识（oracle官方文档）


### 1.与JVM性能相关的组件

在调整性能时，JVM有三个组件主要是关于优化的。

![](/images/posts/jvm/Slide2.PNG)

堆
主要是对象的数据存储。然后，此区域由启动时选择的垃圾收集器管理。

Garbage Collector
垃圾回收器

JIT Compiler
JIT编译器

大多数调优选项都与调整堆大小和为您的情况选择最合适的垃圾收集器有关。
JIT编译器对性能也有很大影响，但很少需要使用较新版本的JVM进行调优。
	

### 2.性能基础知识

通常，在调优Java应用程序时，重点是两个主要目标之一：响应性或吞吐量

响应性:是指应用程序或系统对请求的数据进行响应的速度。
例子包括：
	桌面UI响应事件的速度有多快
	网站返回页面的速度有多快
	返回数据库查询的速度有多快
	对于专注于响应性的应用程序，大的暂停时间是不可接受的。重点是在短时间内做出回应。

吞吐量:吞吐量侧重于在特定时间段内最大化应用程序的工作量。
如何衡量吞吐量的示例包括：
	在给定时间内完成的交易数量。
	批处理程序可在一小时内完成的作业数。
	可在一小时内完成的数据库查询数。
	对于专注于吞吐量的应用程序，高暂停时间是可接受的 由于高吞吐量应用程序在较长时间内专注于基准测试，因此不需要考虑快速响应时间。
	
### 3.什么是自动垃圾收集？

自动垃圾收集是查看堆内存，识别正在使用哪些对象以及哪些对象未使用的过程，以及删除未使用的对象。
使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。
因此可以回收未引用对象使用的内存。


在Java中，解除分配内存的过程由垃圾收集器自动处理。

基本过程：
		
第1步：标记

该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用哪些内存不再使用。


![](/images/posts/jvm/1.png)


A live object 代表存活的对象，也就是还有对象引用，用蓝色表示。

Unreferenced Objects 未引用的对象，用黄金色表示。

在在标记阶段需要扫描所有对象来进行确定是否引用，如果必须扫描系统中的所有对象，则这可能是非常耗时的过程。
	
	
第2步：正常删除

正常删除会删除未引用的对象，从而保留引用的对象和指向可用空间的指针。

![](/images/posts/jvm/2.png)

内存分配器保存对可以分配新对象的可用空间块的引用。


步骤2a：使用压缩删除

要进一步提高性能，除了删除未引用的对象外，还可以压缩剩余的引用对象。

通过将引用的对象移动到一起，这使得新的内存分配更加容易和快速。

![](/images/posts/jvm/3.png)


### 4.为什么分代垃圾收集？




## 深入理解java虚拟机

### 3.5垃圾收集器

1.垃圾收集器的基础概念

![](/images/posts/jvm/4.png)

垃圾收集器是内存回收的具体实现
上图如果两个收集器之间存在连线，说明它们可以搭配使用。


2.Serial收集器
    Serial收集器：
	1.单线程收集器
	2.进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
	3.新生代采取复制算法，暂停所有用户线程。老年代采用标记-整理算法，暂停所有用户线程。
	4.从Serial到G1，用户线程的停顿时间在不断缩短，但是仍然没办法完全消除。
	5.Serial并不是完全无用，它依然是虚拟机运行在Client模式下的默认新生代收集器。
	它也有着优于其他收集器的地方：简单而高效，对于限定的单个CPU环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
	在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代，停顿时间完全可以控制在几十毫秒内最多一百毫秒内，只要是不频繁发生，这点停顿完全是可以接受的。

3.ParNew收集器
    ParNew收集器：
	1.ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余基本行为包括Serial收集器可用的所有控制参数。。。。。都与Serial收集器一样。
	2.运行在Server模式下的虚拟机中首选的新生代收集器。
	3.目前只有ParNew收集器能与CMS收集器配合工作。CMS是划时代的收集器，是第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程基本同时工作
	4.ParNew使用-XX：+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX：+UseParNewGC选项来强制指定它。
	5.可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。

## 工作中调优实践

### 1.我们项目v2版本中jvm参数（未优化）

-Server启动     

-Xms 初始堆大小

-Xmx 最大堆内存

-Xss 设置每个线程的堆栈大小

-XX:MetaspaceSize ：
JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区
别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本
地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值
进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过
MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-verbose:gc
Java -verbose:gc 中参数-verbose:gc 表示输出虚拟机中GC的详细情况.

-Xloggc:gc.log
-Xloggc:../logs/gc.log 日志文件的输出路径

-XX:+PrintGCDateStamps 
GC发生的时间信息

-XX:+PrintGCDetails
打印GC详细信息
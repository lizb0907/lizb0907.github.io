---
layout: post
title: Jvm实战、调优记录
categories: Jvm
description: 记录JVM相关，调优实践
keywords: JVM, GC，调优
---

java垃圾收集基础知识（oracle官方文档）,总结深入理解java虚拟机



**目录**

* TOC
{:toc}

## java垃圾收集基础知识（oracle官方文档）


### 1.与JVM性能相关的组件

在调整性能时，JVM有三个组件主要是关于优化的。

![](/images/posts/jvm/Slide2.PNG)

堆
主要是对象的数据存储。然后，此区域由启动时选择的垃圾收集器管理。

Garbage Collector
垃圾回收器

JIT Compiler
JIT编译器

大多数调优选项都与调整堆大小和为您的情况选择最合适的垃圾收集器有关。
JIT编译器对性能也有很大影响，但很少需要使用较新版本的JVM进行调优。
	

### 2.性能基础知识

通常，在调优Java应用程序时，重点是两个主要目标之一：响应性或吞吐量

响应性:是指应用程序或系统对请求的数据进行响应的速度。
例子包括：
	桌面UI响应事件的速度有多快
	网站返回页面的速度有多快
	返回数据库查询的速度有多快
	对于专注于响应性的应用程序，大的暂停时间是不可接受的。重点是在短时间内做出回应。

吞吐量:吞吐量侧重于在特定时间段内最大化应用程序的工作量。
如何衡量吞吐量的示例包括：
	在给定时间内完成的交易数量。
	批处理程序可在一小时内完成的作业数。
	可在一小时内完成的数据库查询数。
	对于专注于吞吐量的应用程序，高暂停时间是可接受的 由于高吞吐量应用程序在较长时间内专注于基准测试，因此不需要考虑快速响应时间。
	
### 3.什么是自动垃圾收集？

自动垃圾收集是查看堆内存，识别正在使用哪些对象以及哪些对象未使用的过程，以及删除未使用的对象。
使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。
因此可以回收未引用对象使用的内存。


在Java中，解除分配内存的过程由垃圾收集器自动处理。

基本过程：
		
第1步：标记

该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用哪些内存不再使用。


![](/images/posts/jvm/1.png)


A live object 代表存活的对象，也就是还有对象引用，用蓝色表示。

Unreferenced Objects 未引用的对象，用黄金色表示。

在在标记阶段需要扫描所有对象来进行确定是否引用，如果必须扫描系统中的所有对象，则这可能是非常耗时的过程。
	
	
第2步：正常删除

正常删除会删除未引用的对象，从而保留引用的对象和指向可用空间的指针。

![](/images/posts/jvm/2.png)

内存分配器保存对可以分配新对象的可用空间块的引用。


步骤2a：使用压缩删除

要进一步提高性能，除了删除未引用的对象外，还可以压缩剩余的引用对象。

通过将引用的对象移动到一起，这使得新的内存分配更加容易和快速。

![](/images/posts/jvm/3.png)


### 4.为什么分代垃圾收集？




## 深入理解java虚拟机


## 工作中调优实践

### 1.我们项目v2版本中jvm参数（未优化）

-Server启动     

-Xms 初始堆大小

-Xmx 最大堆内存

-Xss 设置每个线程的堆栈大小

-XX:MetaspaceSize ：
JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区
别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本
地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值
进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过
MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-verbose:gc
Java -verbose:gc 中参数-verbose:gc 表示输出虚拟机中GC的详细情况.

-Xloggc:gc.log
-Xloggc:../logs/gc.log 日志文件的输出路径

-XX:+PrintGCDateStamps 
GC发生的时间信息

-XX:+PrintGCDetails
打印GC详细信息
---
layout: post
title: 类加载机制
categories: Jvm
description: 类加载机制
keywords: JVM,Class,Load
---

类加载机制

**目录**

* TOC
{:toc}

## 简介

```sh
1.在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。
2.Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最
终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。
3.在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java
语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用
提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态
连接这个特点实现的。
```

## 类加载的时机

![](/images/posts/jvm/class-load/1.png)

```sh
如上图:
1.其中验证、准备、解析三个部分统称为连接（Linking）。
2.加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按
照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，
这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
```

```sh
对于初始化阶段，《Java虚拟机规范》
则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之
前开始）：
1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始
化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
·使用new关键字实例化对象的时候。
·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
的时候。
·调用一个类型的静态方法的时候。
2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需
要先触发其初始化。
3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先
初始化这个主类。
5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解
析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句
柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有
这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语
——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。

除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
```

```sh
/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 **/
class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}
/**
 * 非主动使用类字段演示
 **/
class NotInitialization
{
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}

输出：
SuperClass init!
123

结论：
会输出“SuperClass init！” 和 “123”，而不会输出“SubClass init！”。对于静态字段，
只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发
父类的初始化而不会触发子类的初始化。
```

## 类加载的过程

### 1.加载

```sh
1.通过一个类的全限定名来获取定义此类的二进制字节流。
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
```

### 2.验证

```sh
验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚
拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
```
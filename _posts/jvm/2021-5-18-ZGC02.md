---
layout: post
title: ZGC-乍一看ZGC(02)
categories: Jvm
description: ZGC-乍一看ZGC(02)
keywords: JVM,ZGC
---

A FIRST LOOK INTO ZGC 文章翻译学习

**目录**

* TOC
{:toc}

## 乍一看ZGC

参考链接：
  https://dinfuehr.github.io/blog/a-first-look-into-zgc/

```sh
1.ZGC是Oracle最近为OpenJDK开源的一个新的垃圾收集器。它的主要作者是Per Liden。
2.ZGC与Shenandoah或Azul’s C4相似，主要关注于减少暂停时间，同时仍然会进行堆的压缩。
3.堆的压缩可以简单理解为将存活的对象，移动到其它region。这可以减少内存的碎片化，但是gc时应用线程需要暂停。
4.根据堆的大小，这样的暂停可能需要几秒钟，这对于交互式应用程序来说可能是很成问题的。
```

```sh
有几种方法可以减少gc暂停:
   .GC在压缩时可以使用多个线程(并行压缩)。
   .压缩工作也可以切分为多个暂停进行（增量压缩）。
   .并发进行压缩堆操作，同时应用线程不暂停。(或者只是短时间内) (并发压缩)。
   .根本不压缩堆(例如Go GC所采用的方法)。

ZGC使用并发压缩堆，以便保持最小的暂停。这显然不容易实现，所以我想描述一下它是如何工作的。为什么这么复杂?
   .你需要拷贝一个对象到另一个内存地址，与此同时其它线程可以从旧对象中读取或写入。
   .如果复制成功，那么堆中仍可能有许多对旧对象地址的任意引用需要更新到新地址。

尽管并发压缩似乎是减少上述替代方案暂停时间的最佳解决方案,但肯定也会有一些取舍。所以，如果你不关心暂停时间，
也许使用一个关注吞吐量的GC可能会更好。
```

## GC屏障（读屏障）

```sh
1.ZGC进行并发压缩的关键load barrier（在GC文献里又通常加read barrier, 也就是读屏障）。

2.如果GC有读屏障，当从堆中读取引用时需要做一些额外的操作。基本上在java里，当你看到类似obj.field代码这种情况就会发生。
  GC还可能需要对obj.field = value之类的操作执行write/store-barrier（写入/存储屏障）。
  这两个操作都是特殊的，因为他们从堆内存读取或写入。

3.名称有点令人困惑，但GC屏障不同于cpu或编译器中的内存屏障。
```

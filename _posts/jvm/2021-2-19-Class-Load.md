---
layout: post
title: 类加载机制
categories: Jvm
description: 类加载机制
keywords: JVM,Class,Load
---

类加载机制

**目录**

* TOC
{:toc}

## 简介

```sh
1.在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。
2.Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最
终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。
3.在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java
语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用
提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态
连接这个特点实现的。
```

## 类加载的时机

![](/images/posts/jvm/class-load/1.png)

```sh
如上图:
1.其中验证、准备、解析三个部分统称为连接（Linking）。
2.加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按
照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，
这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
```

```sh
对于初始化阶段，《Java虚拟机规范》
则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之
前开始）：
1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始
化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
·使用new关键字实例化对象的时候。
·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
的时候。
·调用一个类型的静态方法的时候。
2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需
要先触发其初始化。
3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先
初始化这个主类。
5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解
析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句
柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有
这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语
——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。

除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
```

```sh
/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 **/
class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}
/**
 * 非主动使用类字段演示
 **/
class NotInitialization
{
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}

输出：
SuperClass init!
123

结论：
会输出“SuperClass init！” 和 “123”，而不会输出“SubClass init！”。对于静态字段，
只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发
父类的初始化而不会触发子类的初始化。
```

## 类加载的过程

### 1.加载

```sh
1.通过一个类的全限定名来获取定义此类的二进制字节流。
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
```

### 2.连接（三个步骤）

#### 1.验证

```sh
验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚
拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
```

#### 2.准备

```sh
准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初
始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区
本身是一个逻辑上的区域，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这
种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在
方法区”就完全是一种对逻辑概念的表述了。
```

```sh
这里所说的初始值“通常情况”下是数据类型的零值：
   public static int value = 123;

那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把
value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值
为123的动作要到类的初始化阶段才会被执行。
```

```sh
如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定
的初始值：
  public static final int value = 123;  //这里被final修饰

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置
将value赋值为123。
```

#### 3.解析

```sh
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何
形式的字面量，只要使用时能无歧义地定位到目标即可。

直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能
间接定位到目标的句柄。

说白了就是jvm会将所有的类或接口名、字段名、方法名...转换为具体的内存地址。
```

### 初始化

```sh
进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通
过程序编码制定的主观计划去初始化类变量和其他资源。

我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器<clinit>()方法的过程。
<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。

静态变量（类变量）赋值的过程，即只有static修饰的才能被初始化。
```

## 类加载器

```sh
Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节
流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动
作的代码被称为“类加载器”（Class Loader）。
```

### 1.双亲委派模型

![](/images/posts/jvm/class-load/2.png)

```sh
站在Java虚拟机的角度来看，只存在两种不同的类加载器：
  1.启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现 [1] ，是虚拟机自身的一部分。
  2.另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承
  自抽象类java.lang.ClassLoader。

站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保
持着三层类加载器、双亲委派的类加载架构。
```
```sh
图7中各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation
Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载
器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用
组合（Composition）关系来复用父加载器的代码。
```

```sh
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加
载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的
加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请
求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。
```

```sh
使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类
加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一
个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类
在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个
类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的
ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应
用程序将会变得一片混乱。
```

#### 1.启动类加载器

```sh
·启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在
<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够
识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类
库加载到虚拟机的内存中。
```

#### 2.扩展类加载器

```sh
·扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader
中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所
指定的路径中所有的类库。
```

#### 3.应用程序类加载器

```sh
这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-
ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径
（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有
自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
```

### 总结

```sh
总结（非常重要）：
  1.应用程序类加载器，负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有
    自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
  2.如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
  3.我们自定义类加载器加载类时，需要父加载器已经卸载过该对象或者让指定父类路径找不到要加载的类，否则会报重复。
    例如：
        ClassPath下有一个Student.java类，那么会是应用程序类加载器加载该类。我们自定义了一个类加载器尝试重新加载Student类以达到热更
        目的，但是由于自定义类不会优先自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，所以如果应用程序类加载器已经加载过该类，
        那么会报重复加载错误，导致热更失败。

        自定义类加载器加载某个类时，必须保证父加载器没有加载过该类或者父类加载路径找不到要加载的类。
        通常而言，我们如果要用自定义类加载器来加载已有的类从而达到热更类的目的，我们会将要加载的类放到父类加载器找不到的路径，从而让自定义
        加载器可以加载当前类。但是要注意，如果父类加载器已经加载过之前的类，如果不卸载类对象，不停的热更，会造成内存泄露。

```
---
layout: post
title: JVM调优使用工具
categories: Jvm
description: JVM调优使用工具
keywords: JVM,TOOls
---

JVM调优使用工具

**目录**

* TOC
{:toc}

## 一些好的jvm调优链接

### 1.G1调优官方指南必看：

http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html

### 2.不错的博客系列

jvm调优1-4：
https://www.cnblogs.com/chiangchou/p/jvm-1.html
https://www.cnblogs.com/chiangchou/p/jvm-2.html
https://www.cnblogs.com/chiangchou/p/jvm-3.html
https://www.cnblogs.com/chiangchou/p/jvm-4.html#_label3

## JDK内置工具

### 1.分类

```sh
大体分为：
    1.监控类工具：jps, jstat
    2.故障排查工具:
      jinfo, jmap, jstack, jcmd,
      jhat, jhsdb
    3.可视化工具:jconsole,visualvm,jhsdb
```
### 1.监控工具

#### 1.jps主要监控进程

```sh
参考文档：
  java 8 ：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html

使用说明:
  1. 直接键入 jps  //显示java进程
  2. jps -m       //显示传入main方法参数
  3. jps -ml      //显示传入main方法参数，同时显示启动类包名
  4. jps -v       //显示传递给jvm的参数

jps 命令有点类似 ps -ef | grep java 命令，
但 jps 命令显示的格式更友好。 

jps还可以查看远程服务器的jvm进程信息，需要一些配置，使用rmi协议
        jps -l remote.domain //端口1099
        jps -l rmi://remote.comain:1231
```

#### 2.jstat监控jvm各种运行状态

![](/images/posts/jvm/jvm-tools/1.png)

如同，红色框内就是列标题，很重要！

```sh
参考文档：
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html

使用说明:
  格式：jstat [ generalOption | outputOptions vmid [ interval[s|ms] [ count ] ]

  generalOption可选参数如下：
    1.class       //显示类加载器的统计信息
    2.compiler    //显示有关jvm即时编译器行为的统计信息
    3.gc          //显示有关垃圾收集堆行为的统计信息
    4.gccause     //显示引起垃圾收集事件的原因
    ...

  outputOptions:
    1.-t           //将时间戳显示为输出的第一列
    2.-hn          //n为第几次，表示n次采样后输出一次列标题

  vmid：           //进程的唯一标识

  interval：       //间隔多长时间输出1次

  count:           //输出多少次后退出

例子：
  jstat -gc -t -h3 26000 1000 10
  每隔1000毫秒输出一次gc统计信息，输出10次退出，同时将时间戳显示为输出的第一列，每3次
  采样后输出一次列标题。
  gc列标题含义(官网上都有详细说明):
    S0C：第一个幸存区的大小
    S1C：第二个幸存区的大小
    S0U：第一个幸存区的使用大小
    S1U：第二个幸存区的使用大小
    EC：eden的大小
    EU：eden使用大小
    OC：老年代大小
    OU：老年代使用大小
    MC：方法区大小
    MU：方法区使用大小
    CCSC:压缩类空间大小
    CCSU:压缩类空间使用大小
    YGC：年轻代垃圾回收次数
    YGCT：年轻代垃圾回收消耗时间
    FGC：老年代垃圾回收次数
    FGCT：老年代垃圾回收消耗时间
    GCT：垃圾回收消耗总时间
```

```sh
使用jstat看G1的时候，s0永远是0：
  因为G1的堆布局跟HotSpot VM里其它GC不一样——它只有一组逻辑上的survivor space，
  而不像其它HotSpot GC一样有两段明确、固定的地址空间用作survivor space——所以用jstat
  看G1的话肯定是survivor space 0显示0%，survivor space 1显示100%。这个是正常的。

G1在初始化jstat用的计数器的时候就指定了s0永远是0:
  //  name "generation.0.space.1"  
  // See _old_space_counters for additional counters  
  // Set the arguments to indicate that this survivor space is not used.  
  _from_counters = new HSpaceCounters("s0", 1 /* ordinal */,  
  pad_capacity(0) /* max_capacity */,  
  pad_capacity(0) /* init_capacity */,  
  _young_collection_counters);  

  //  name "generation.0.space.2"  
  // See _old_space_counters for additional counters  
  _to_counters = new HSpaceCounters("s1", 2 /* ordinal */,  
  pad_capacity(overall_reserved()) /* max_capacity */,  
  pad_capacity(survivor_space_committed()) /* init_capacity */,  
  _young_collection_counters);  

来源R大帖子回复（https://hllvm-group.iteye.com/group/topic/42352）
```

### 2.故障排查工具

#### 1.jinfo主要用来查看与调整JVM参数

可以打印系统属性和JVM参数，同时支持部分参数动态修改！
```sh
参考文档:
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html

使用说明：
  jinfo [ option ] pid

  查看例如：
     1.jinfo -flags 进程id        //打印指定进程的VM参数
     2.jinfo -sysprops 进程id     //只打印系统属性
     3.jinfo -flag UseG1GC 进程id //打印UseG1GC参数的值（判断是否开启G1）
     4.jinfo -flag ThreadStackSize 进程id   //查看线程栈的指定大小
  
  动态修改参数(可以达到不重启应用改变参数)：
     1.使用如下命令显示出来的参数，基本上都是支持动态修改的：
         java -XX:PrintFlagsInitial | grep manageable
         如果显示的规则是true或者false：
            jinfo -flag +HeapDumpAfterFullGC 进程id      //+表示开，-表示关闭
         如果显示的规则是数字，则以key,value形式:
            jinfo -flag MinHeapFreeRatio=60 进程id       //修改MinHeapFreeRatio值为60
```

#### 2.jmap全称Java Memory Map, 用来展示对象内存映射或堆内存详细信息

```sh
参考文档:
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html

使用说明：
  jmap [options] pid

options常用选项:
  1.-clstats    //打印Java堆的类加载器统计信息

  2.-dump:dump_options:       //转存java堆
          live   //指定时，仅Dump活动对象；如果未指定，则转存堆中所有对象
          format=b: //以hprof格式Dump堆
          file=filename: //将堆Dump到filename
      例如：jmap -dump:live,format=b,file=myDump.hprof pic     //可以不指定live
            执行完命令后，可以在当前目录下找到文件，直接ll查看

  3.-finalizerinfo: //打印等待回收的对象
  4.-histo[:live]:   //打印堆的直方图，如果指定live子选项，则仅统计活动对象

扩展除了使用jmap存储堆内存，还可以：
  1.使用-XX:+HeapDumpOnOutOfMemoryError  //OOM异常后自动生成堆Dump文件
  2.使用-XX:+HeapDumpOnCtrlBreak,可以使用[Ctrl]+[Break],
    让虚拟机生成堆Dump文件。
  3.linux操作系统下，发送kill -3 pid命令
```

#### 3.jstack用于打印当前虚拟机的线程快照

是对线程的Dump，也较Thread Dump

```sh
参考文档：
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html

使用说明：
  jstack [-l][-e] <pid>

options:
  -l 显示有关锁的额外信息
  -e 展示有关线程的额外信息（比如分配了多少内存、定义了多少个类等等）  

例如：
   1.jstack pid   //不带任何参数，显示线程在干嘛

   2.对比,输出到指定文件
     jstack pid > t1.txt
     jstack -l pid > t2.txt //带 -l 参数会显示锁额外信息，
                            //输出这个线程所持有的锁对象
     jstack -l -e pid > t3.txt //多显示线程分配了多少内存、定义了多少个类

直接看比较类，有可视化分析jstack dump出来的结果
```

#### 4.jhat用来分析jmap生成的堆Dump文件

全程JVM Heap Analysis Tool，

```sh
不太建议使用，功能比较弱。可以使用：
     1.VisualVm
     2.Eclipse Memory Analyzer
```

```sh
参考文档：
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html
```

#### 5.jcmd，用于将诊断命令发送到jvm

全程JVM Command

```sh
参考文档：
  java 8 : https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jcmd.html

很多功能类似和其它命令类似:
    1.jcmd -l 列出本机上所有jvm进程
    2.jcmd pid GC.heap_dump -all myheapdump.hprof  //类似jmap存储内存
    3.jcmd pid GC.heap_info //通知jvm做一次垃圾回收

```

### 3.可视化工具

#### 1.jconsole

可视化监控、管理工具。它主要通过JMX的MBean对系统进行信息收集和参数动态调整。

使用比较简单，傻瓜化。

启动命令：
```sh
直接键入jconsole，就会弹出窗口。
可以选择本机进行和远程进程。
```

#### 2.VisualVm

是目前监控以及故障排查最强大的工具之一。

JDK9以及更高不支持内置，需要单独下载

启动命令：
```sh
直接键入jvisualvm，就会弹出窗口。
可以选择本机进行和远程进程。
```

##### 1.Overview窗口：
```sh
概览 
```

##### 2.Monitor窗口:

![](/images/posts/jvm/jvm-tools/2.png)

```sh
CPU,Heap,Classes,Threads曲线图；

Perform GC按钮， 执行垃圾回收；

headdump 按钮，堆内存快照：
     save 另存
     Summary 分析
```

##### 3.Threads窗口:
```sh
特别关注：
   Running    //表示运行时花费的时间
   Total      //表示从创建到现在花费的时间
   右上角，Thead Dump   //线程快照，相当于可视化的jstack
```

##### 4.Sampler抽样窗口:

###### 1.CPU抽样(点击CPU)：

![](/images/posts/jvm/jvm-tools/3.png)

CPU Samples:
```sh
 1.cpu:
      Total Time,这些线程从开始抽样到现在花费的时间
      Total Time(CPU), 这些线程从开始抽样到现在占用cpu的时间
2.可以展开线程，查看当前线程执行调用栈：
      点击热点按钮，可以发现当前线程调用最热的方法（两个小箭头之间的红色按钮）
          Self Time（CPU）  //自身花费时间
          Total Time(CPU)   //总共花费时间，包含调用其它方法时间
```

![](/images/posts/jvm/jvm-tools/4.png)

Thread CPU Times:
```sh
可以知道哪个线程花费的CPU时间最多：
    红色圈1：各个线程所占用CPU的时间比
    红色圈2：最近1秒的时间抽样，各个线程在1秒内花费CPU时间
```

###### 2.内存抽样（点击Memory）：

![](/images/posts/jvm/jvm-tools/5.png)

```sh
Heap histogram:
   堆内存柱状图

Per thread allocations:
   jvm为每个线程分配的内存，可以看出哪个线程占用的内存大。
```
   
##### 5.Profiler性能分析:

性能分析，提供了程序运行期 方法级别 的处理器执行时间分析以及内存分析。

CPU性能分析、内存性能分析、JDBC性能分析。

可以配置想检查的范围。

注意事项：
```sh
1.执行性能分析，会对程序运行性能有比较大的影响，一般不建议在生产环境使用这项
  功能。可以在开发测试环境去分析调优，也可以用JMC替代，JMC性能分析能力更强，
  而且影响相对小很多。
2.类共享（类共享是一种共享类，从而提升加载速度、节省内存的技术）可能会导致执行
  Profiler的应用崩溃，建议在执行Profiler的应用上添加-Xshare:off（VM参数上添加就行）,
  关闭类共享。否则，点击按钮的时候应用可能会崩溃。
```

![](/images/posts/jvm/jvm-tools/6.png)

![](/images/posts/jvm/jvm-tools/7.png)

```sh
配置性能分析参数：
点击左上角VisualVM-->Preferences:
   可以配置想要监控的CPU,内存，Sql语句。
```

![](/images/posts/jvm/jvm-tools/8.png)

![](/images/posts/jvm/jvm-tools/9.png)


##### 5.之间打开各种格式文件进行分析:

点击左上角File--->load

![](/images/posts/jvm/jvm-tools/10.png)

例如：打开hprof分析堆内存

Summary:
```sh
比较重要参数：
   Classes by Number of Instances[view all] //指定类型个数对象倒叙排列
   Classes by Size of Instances[view all] //指定类型占用空间的倒叙排列 
   Instaces by Size[view all] //当前堆内存里面每个对象所占用内存
   Dominators by Retained Size[view all] // 未支配对象所保存的内存空间

假设堆内存不正常，我们可以点击view all，来查看哪个类型的对象占用最多
...
其它类似
```

##### 5.使用插件

左上角Tools-->Plugins-->Availabel Plugins, 进一步增强功能。

例如Visul GC, 可以看到可视化的垃圾回收过程。

#### 3.JMC

```sh
JDK Mission Control：
  JMC两大功能：
    1.作为JMX控制台，监控虚拟机MBean提供的数据：
      JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。
      JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理
      和服务实现管理。主要用于对JAVA应用程序和JVM进行监控和管理。

JConsole和JVisualVM中能够监控到JAVA应用程序和JVM的相关信息都是通过JMX实现的。
    2.可持续收集数据JFR(Java Flight Recorder), 并可作为
      JFR的可视化分析工具。
    
  JFR(Java Flight Recorder)是一种用于收集有关运行中的Java
  应用的诊断信息和性能收集的工具。它几乎没有性能开销，因此在负载
  很大的生产环境中也可以使用。

```



---
layout: post
title: 极客java并发实战学习记录
categories: Concurrent
description: 极客ava并发实战学习记录
keywords: concurrent, study, recoard
---

极客上王宝令老师讲的ava并发实战，感觉讲得不错，所以记录一些要点。


**目录**

* TOC
{:toc}

## 并发的理论基础

### 如何学习好并发？

跳出来看全景 并发的三个核心：分工、同步和互斥 <br>
思维导图：
![](/images/posts/concurrent/1.png)

### 01.并发bug源头？

#### 1.缓存导致的可见性问题

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。<br>
cpu增加了缓存，以均衡与内存的速度差异。多核时代，每颗cpu都有自己的缓存，这时cpu的缓存与内存
的数据一致性就没那么容易解决了，当多个线程在不同的cpu上执行时，这些线程操作的是不同的cpu缓存。<br>

#### 2.线程切换带来的原子性问题

我们把一个或者多个操作在cpu执行的过程中不被中断的特性称为原子性。
高级语言里一条语句往往需要多条cpu指令完成。

1.count += 1 操作至少需要三条cpu指令

    a.count从内存加载到cpu寄存器
  
	b.执行加1操作
  
	c.写回内存或者cpu缓存  
  
这时候如果发生线程切换就会产生意想不到的结果。

#### 3.编译优化带来的有序性问题

编译器有时候为了优化性能会改变代码的执行顺序。例如：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”
有时候编译器因为这种原因也会产生bug。

![](/images/posts/concurrent/2.png)

1.new Singleton()原本执行顺序

    a.分配一块内存
  
	b.在内存上初始化对象
  
	c.将地址赋给instance变量
  
2.new Singleton()编译器优化后

	a.分配一块内存

	b.将内存地址赋给instance变量

	c.最后在内存地址上初始化Singleton对象
  
这样就会产生问题，假设A线程先调用为了getInstance()方法，当进行到指令2时发生了线程切换，此时还没有初始化
Singleton对象。B线程进来，判断instance != null ，所以直接返回 instance，这时候如果访问instance就报空指针
异常了。

### 02.java内存模型:如何解决可见性和有序性？

#### 1.什么是java内存模型？

java内存模型，站在程序员的视角，可以理解为规范了JVM如何提供按需禁用缓存和编译优化的方法。


#### 2.如何解决可见性和有序性？

合理的方案应该是按需禁用缓存以及编译优化。

#### 3.volatile

volatile int x = 0 告诉编译器，对这个变量的读写，不能使用cpu缓存，必须从内存中读取或者写入。

#### 4.Happens-Before规则

前面一个操作的结果对后续操作是可见的。

1.程序的顺序性规则

这条规则是指在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作。

2.volatile变量规则

一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 的读操作。

3.传递性

这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

4.管程中锁的规则

管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

5.线程start()规则

它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

#### 5.final

final 修饰变量时，初衷是告诉编译器:这个变量不会发生变化，可以使劲优化。

### 03.如何解决原子性问题？

原子性问题源头是线程切换，禁用线程切换方案，在单核时代可行，但是多核时代不可行。

在多核时代，可能有多个cpu对同一个变量进行操作，光禁止某个线程不发生切换，不能保证同一时刻只有
一个线程执行。

那么如何保证原子性问题？

“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。所以我们自然想到用:锁。

#### 1.java里的锁: synchronized

Java 语言提供的 synchronized 关键字，就是锁的一种实现

```java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
```

## 并发工具类


### 线程池


## 并发设计模式

## 按列分析

## 其他并发模型



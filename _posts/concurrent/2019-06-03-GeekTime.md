---
layout: post
title: 极客java并发实战学习记录
categories: Concurrent
description: 极客ava并发实战学习记录
keywords: concurrent, study, recoard
---

极客上王宝令老师讲的ava并发实战，感觉讲得不错，所以记录一些要点。


**目录**

* TOC
{:toc}

## 并发的理论基础

### 如何学习好并发？

跳出来看全景 并发的三个核心：分工、同步和互斥 <br>
思维导图：
![](/images/posts/concurrent/1.png)

### 01.并发bug源头？

#### 1.缓存导致的可见性问题

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。<br>
cpu增加了缓存，以均衡与内存的速度差异。多核时代，每颗cpu都有自己的缓存，这时cpu的缓存与内存
的数据一致性就没那么容易解决了，当多个线程在不同的cpu上执行时，这些线程操作的是不同的cpu缓存。<br>

#### 2.线程切换带来的原子性问题

我们把一个或者多个操作在cpu执行的过程中不被中断的特性称为原子性。
高级语言里一条语句往往需要多条cpu指令完成。

1.count += 1 操作至少需要三条cpu指令

    a.count从内存加载到cpu寄存器
  
	b.执行加1操作
  
	c.写回内存或者cpu缓存  
  
这时候如果发生线程切换就会产生意想不到的结果。

#### 3.编译优化带来的有序性问题

编译器有时候为了优化性能会改变代码的执行顺序。例如：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”
有时候编译器因为这种原因也会产生bug。

![](/images/posts/concurrent/2.png)

1.new Singleton()原本执行顺序

    a.分配一块内存
  
	b.在内存上初始化对象
  
	c.将地址赋给instance变量
  
2.new Singleton()编译器优化后

	a.分配一块内存

	b.将内存地址赋给instance变量

	c.最后在内存地址上初始化Singleton对象
  
这样就会产生问题，假设A线程先调用为了getInstance()方法，当进行到指令2时发生了线程切换，此时还没有初始化
Singleton对象。B线程进来，判断instance != null ，所以直接返回 instance，这时候如果访问instance就报空指针
异常了。

### 02.java内存模型:如何解决可见性和有序性？

#### 1.什么是java内存模型？

java内存模型，站在程序员的视角，可以理解为规范了JVM如何提供按需禁用缓存和编译优化的方法。


#### 2.如何解决可见性和有序性？

合理的方案应该是按需禁用缓存以及编译优化。

#### 3.volatile

volatile int x = 0 告诉编译器，对这个变量的读写，不能使用cpu缓存，必须从内存中读取或者写入。

#### 4.Happens-Before规则

前面一个操作的结果对后续操作是可见的。

1.程序的顺序性规则

这条规则是指在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作。

2.volatile变量规则

一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 的读操作。

3.传递性

这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

4.管程中锁的规则

管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

所以如果有一个共享变量有一个set和一个get方法，如果只对set方法加synchronized是不够的，管程中锁的规则，是只保证后续对这个锁的加锁的可见性，
而 get() 方法并没有加锁操作，所以可见性没法保证。正确的做法如下：

```java
class SafeCalc {
  long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
```

5.线程start()规则

它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

#### 5.final

final 修饰变量时，初衷是告诉编译器:这个变量不会发生变化，可以使劲优化。

### 03.如何解决原子性问题？

原子性问题源头是线程切换，禁用线程切换方案，在单核时代可行，但是多核时代不可行。

在多核时代，可能有多个cpu对同一个变量进行操作，光禁止某个线程不发生切换，不能保证同一时刻只有
一个线程执行。

那么如何保证原子性问题？

“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。所以我们自然想到用:锁。

#### 1.java里的锁: synchronized

Java 语言提供的 synchronized 关键字，就是锁的一种实现

```java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
```

Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock。

当修饰静态方法的时候，锁定的是当前类的 Class 对象：

```java
class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
```

当修饰非静态方法的时候，锁定的是当前实例对象 this。

```java
class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
```

#### 2.锁和受保护资源的关系

受保护资源和锁之间的关联关系是 N:1 的关系，也就是多个资源可以受同一个锁保护。

#### 3.课后思考题，下面的代码可以解决可见性和原子性问题吗？

```java
class SafeCalc {
  long value = 0L;
  long get() {
    synchronized (new Object()) {
      return value;
    }
  }
  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
```

不可以，加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。

#### 4.补充一点，阅读<<java并发编程实战>>书籍里将到的一点

synchronized并不是只解决原子性，也就是说synchronized并不是只有“互斥特性”，synchronized还可以解决可见性，因为
java内存模型里规定管程：一个锁的解锁 Happens-Before 于后续对这个锁的加锁。


### 05.死锁

#### 1.死锁定义

一组互相竞争资源的线程因为互相等待，导致“永久”阻塞的现象。

#### 2.一个死锁的例子

```java
class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this){     ①
      // 锁定转入账户
      synchronized(target){ ②
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```
假设T1和T2两个线程同时进行转账操作，T1执行账号A转账户B，T2执行账户B转账户A。假设T1和T2同时执行到代码1处，
此时T1获得了账户A的锁，T2获得了账户B的锁。当继续往下执行到代码2处，T1发现B账户锁被持有了，于是等待。T2发
现A账户锁被持有，等待。这样互相等待，锁不能被释放，就导致死锁的发生。

#### 3.如何防止死锁？

1.破坏占用且等待条件

“一次性申请所有资源”，上面的转账例子，我们可以加个管理员类Alloactor单例，当账户 Account 在执行转账操作的时候，
首先向 Allocator 同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，
我们需要通知Allocator同时释放转出账户和转入账户这两个资源。

2.破坏不可抢占条件

核心是能够主动释放它占有的资源，synchronized做不到，但是Lock可以解决这个问题。

3.破坏循环等待条件

破坏这个条件，需要对资源进行排序，然后按序申请资源。

```java
class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id > target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance > amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```
因为是按序申请的，所以可以保证只有一个线程同时获得转出和转入账户资源，从而保证不会发生死锁。

### 06.用synchronized实现等待-通知机制

比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以轻松实现。

调用wait()当前线程就会被阻塞并进入等待队列，同时释放持有的互斥锁。

被通知的线程要想重新执行，仍然需要获取到互斥锁。

notify() 是会随机地通知等待队列中的一个线程，notifyAll() 会通知等待队列中的所有线程。

尽量使用notifyAll(), 防止某些线程永远不会被通知到。


### 07.竞态条件，活锁，饥饿

竞态条件，指的是程序的执行结果依赖线程执行的顺序。

有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间
就可以。

所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。如果线程优先级“不均”，在cpu繁忙的情况下，优先级低的线程得到执行的机会
很小，就可能发生线程“饥饿”。

### 08.管程:并发编程的钥匙

#### 1.什么是管程？

管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。

#### 2. MESA模型？

java管程的实现参考的是MESA模型。

管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。

![](/images/posts/concurrent/3.png)

管程如何解决线程间的同步问题呢？

![](/images/posts/concurrent/4.png)

管程里还引入了条件变量概念，每个条件变量都对应一个等待队列。

Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。
MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。

![](/images/posts/concurrent/5.png)

### 09.java的生命周期

java线程的生命周期可以简化为下图:

![](/images/posts/concurrent/6.png)

1. RUNNABLE 与 BLOCKED 的状态转换

synchronized修饰的方法、代码块同一时刻只允许一个线程执行，其它线程只能等待，等待的线程就会从RUNNABLE转换到BLOCKED状态。
当获得锁，就会从BLOCKED转换到RUNNABLE状态。

线程调用阻塞式API，操作系统层面线程会转换到休眠状态，jvm层面，还是RUNNABLE状态。因为在jvm看来，等待CPU使用权与等待I/O
没有区别，都是在等某个资源，所以都归入RUNNABLE状态。

2. RUNNABLE 与 WAITING 的状态转换

获得synchronized隐式锁线程，调用无参数的Object.wait()方法。

调用无参数的Thread.join()方法，例如有一个线程对象 thread A，当调用 A.join 的时候，执行这条语句的线程会等待 thread A 执行
完，而等待中的这个线程会进入WAITING。

调用LockSupport.park()方法。

3. RUNNABLE 与 TIMED_WAITING 状态转换

调用带超时参数Thread.sleep(long millis);

获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；

调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline)方法；

调用带超时参数的 LockSupport.parkUnti(long deadline) 方法。

4. 从 NEW 到 RUNNABLE 状态

调用线程的start()方法

5. 从 RUNNABLE 到 TERMINATED 状态

线程执行完run()方法后，自动转换到 TERMINATED。

调用 stop() （不建议使用）

调用interrupt()

### 10.创建多少线程合适？

对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为
“CPU 核数 +1”。

对于 I/O 密集型计算场景，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]


## 并发工具类


## 线程池


## 并发设计模式

## 按列分析

## 其他并发模型



---
layout: post
title: 极客java并发实战学习记录
categories: Concurrent
description: 极客ava并发实战学习记录
keywords: concurrent, study, recoard
---

极客上王宝令老师讲的ava并发实战，感觉讲得不错，所以记录一些要点。


**目录**

* TOC
{:toc}

## 并发的理论基础

### 如何学习好并发？

跳出来看全景 并发的三个核心：分工、同步和互斥 <br>
思维导图：
![](/images/posts/concurrent/1.png)

### 01.并发bug源头？

#### 1.缓存导致的可见性问题

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。<br>
cpu增加了缓存，以均衡与内存的速度差异。多核时代，每颗cpu都有自己的缓存，这时cpu的缓存与内存
的数据一致性就没那么容易解决了，当多个线程在不同的cpu上执行时，这些线程操作的是不同的cpu缓存。<br>

#### 2.线程切换带来的原子性问题

我们把一个或者多个操作在cpu执行的过程中不被中断的特性称为原子性。
高级语言里一条语句往往需要多条cpu指令完成。

1.count += 1 操作至少需要三条cpu指令

    a.count从内存加载到cpu寄存器
  
	b.执行加1操作
  
	c.写回内存或者cpu缓存  
  
这时候如果发生线程切换就会产生意想不到的结果。

#### 3.编译优化带来的有序性问题

编译器有时候为了优化性能会改变代码的执行顺序。例如：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”
有时候编译器因为这种原因也会产生bug。

![](/images/posts/concurrent/2.png)

1.new Singleton()原本执行顺序

    a.分配一块内存
  
	b.在内存上初始化对象
  
	c.将地址赋给instance变量
  
2.new Singleton()编译器优化后

	a.分配一块内存

	b.将内存地址赋给instance变量

	c.最后在内存地址上初始化Singleton对象
  
这样就会产生问题，假设A线程先调用为了getInstance()方法，当进行到指令2时发生了线程切换，此时还没有初始化
Singleton对象。B线程进来，判断instance != null ，所以直接返回 instance，这时候如果访问instance就报空指针
异常了。

### 02.java内存模型:如何解决可见性和有序性？

#### 1.什么是java内存模型？

java内存模型，站在程序员的视角，可以理解为规范了JVM如何提供按需禁用缓存和编译优化的方法。


#### 2.如何解决可见性和有序性？

合理的方案应该是按需禁用缓存以及编译优化。

#### 3.volatile

volatile int x = 0 告诉编译器，对这个变量的读写，不能使用cpu缓存，必须从内存中读取或者写入。

#### 4.Happens-Before规则

前面一个操作的结果对后续操作是可见的。

1.程序的顺序性规则

	这条规则是指在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作。

2.volatile变量规则

	一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 的读操作。

3.传递性

	这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

4.管程中锁的规则

	a.管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

	b.一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

所以如果有一个共享变量有一个set和一个get方法，如果只对set方法加synchronized是不够的，管程中锁的规则，是只保证后续对这个锁的加锁的可见性，
而 get() 方法并没有加锁操作，所以可见性没法保证。正确的做法如下：

```java
class SafeCalc {
  long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
```

5.线程start()规则

	它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

#### 5.final

final 修饰变量时，初衷是告诉编译器:这个变量不会发生变化，可以使劲优化。

### 03.如何解决原子性问题？

原子性问题源头是线程切换，禁用线程切换方案，在单核时代可行，但是多核时代不可行。

在多核时代，可能有多个cpu对同一个变量进行操作，光禁止某个线程不发生切换，不能保证同一时刻只有
一个线程执行。

那么如何保证原子性问题？

“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。所以我们自然想到用:锁。

#### 1.java里的锁: synchronized

Java 语言提供的 synchronized 关键字，就是锁的一种实现

```java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
```

Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock。

当修饰静态方法的时候，锁定的是当前类的 Class 对象：

```java
class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
```

当修饰非静态方法的时候，锁定的是当前实例对象 this。

```java
class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
```

#### 2.锁和受保护资源的关系

受保护资源和锁之间的关联关系是 N:1 的关系，也就是多个资源可以受同一个锁保护。

#### 3.课后思考题，下面的代码可以解决可见性和原子性问题吗？

```java
class SafeCalc {
  long value = 0L;
  long get() {
    synchronized (new Object()) {
      return value;
    }
  }
  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
```

不可以，加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。

#### 4.补充一点，阅读<<java并发编程实战>>书籍里将到的一点

synchronized并不是只解决原子性，也就是说synchronized并不是只有“互斥特性”，synchronized还可以解决可见性，因为
java内存模型里规定管程：一个锁的解锁 Happens-Before 于后续对这个锁的加锁。


### 05.死锁

#### 1.死锁定义

一组互相竞争资源的线程因为互相等待，导致“永久”阻塞的现象。

#### 2.死锁的例子

```java
class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this){     ①
      // 锁定转入账户
      synchronized(target){ ②
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```
假设T1和T2两个线程同时进行转账操作，T1执行账号A转账户B，T2执行账户B转账户A。假设T1和T2同时执行到代码1处，
此时T1获得了账户A的锁，T2获得了账户B的锁。当继续往下执行到代码2处，T1发现B账户锁被持有了，于是等待。T2发
现A账户锁被持有，等待。这样互相等待，锁不能被释放，就导致死锁的发生。

```java
/**
 * @author lizhibiao
 * @date 2019/7/3 17:32
 */
public class DeadLockRisk {

    private static class LockObject{
        private int value;
    }

    private final LockObject objectA = new LockObject();
    private final LockObject objectB = new LockObject();

    public int read(){
        synchronized (objectA){
            synchronized (objectB){
                return objectA.value + objectB.value;
            }
        }
    }

    public void write(int a, int b){
        synchronized (objectB){
            synchronized (objectA){
                objectA.value = a;
                objectB.value = b;
            }
        }
    }
}
```

当读线程和写线程同时进入各自代码块的一个锁时，读线程获得objectA锁，写线程获得了objectB锁，相互等待对方，造成死锁。
#### 3.如何防止死锁？

1.破坏占用且等待条件

```java
class Allocator {
  private List<Object> als =
    new ArrayList<>();
  // 一次性申请所有资源
  synchronized boolean apply(
    Object from, Object to){
    if(als.contains(from) ||
         als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr 应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target))；
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance > amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
```
“一次性申请所有资源”，上面的转账例子，我们可以加个管理员类Alloactor单例，当账户 Account 在执行转账操作的时候，
首先向 Allocator 同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，
我们需要通知Allocator同时释放转出账户和转入账户这两个资源。申请资源时，只要list列表里包含转入或转出账号中的其中
一个就返回false条件不满足，必须要同时获取转出账户和转入账户这两个资源。如果满足条件，需要往list列表里添加当前正
在使用的转入和转出账户。

2.破坏不可抢占条件

	核心是能够主动释放它占有的资源，synchronized做不到，但是Lock可以解决这个问题。

3.破坏循环等待条件，需要对资源进行排序，然后按序申请资源。

```java
class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id > target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance > amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```
每个账号都有个id字段，id有大小之分。圆圈1~6的代码是对账号id进行了排序。假设账号A的id是100，
账号B的id是200。线程a执行账号A向账号B转账。线程a执行到圆圈3不符合，所以left就是当前账号A，那
下面synchronized(left)锁定的就是自己本身账号A。线程b执行账号B向账号A转账，线程b执行到圆圈3，
执行if块语句，left从账号B变成账号A，所以下面加锁操作也是先申请A账号锁。正因为这样，我们永远
先申请小字段的账号。所以可以保证只有一个线程同时获得转出和转入账户资源，从而保证不会发生死锁。

### 06.用synchronized实现等待-通知机制

破坏占用且等待条件,使用了while循环来等待。
```java
// 一次性申请转出账户和转入账户，直到成功
while(!actr.apply(this, target))；
```
不停的调用apply方法，在某些场景太耗cpu了。所以我们需要用等待-通知机制来优化下。如果线程要求条件不满足，
则阻塞自己，进入等待状态。当条件满足，则通知等待的线程重新执行。使用线程阻塞的方式就能避免循
环等待消耗 CPU 的问题。

Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以轻松实现。

调用wait()当前线程就会被阻塞并进入等待队列，同时释放持有的互斥锁。

```java
class Allocator {
  private List<Object> als;
  // 一次性申请所有资源
  synchronized void apply(
    Object from, Object to){
    // 经典写法
    while(als.contains(from) ||
         als.contains(to)){
      try{
        wait();
      }catch(Exception e){
      }   
    } 
    als.add(from);
    als.add(to);  
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
    notifyAll();
  }
}
```

被通知的线程要想重新执行，仍然需要获取到互斥锁。notify() 是会随机地通知等待队列中的一个线程，
notifyAll() 会通知等待队列中的所有线程。尽量使用notifyAll(), 防止某些线程永远不会被通知到。

课后思考题，面试都会问到wait()方法 和 sleep（）方法的区别？

1. wait会释放所有锁而sleep不会释放锁资源.

2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.

3. wait无需捕捉异常，而sleep需要.

4. wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，
将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，
会将对象等待池中的所有线程都移动到该对象的锁标志等待池。

5. sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，
该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。
但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。

### 07.竞态条件，活锁，饥饿

1.竞态条件，指的是程序的执行结果依赖线程执行的顺序。

2.有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。类比现实世界，甲从左手边出门，
乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种
情况，人基本谦让几次就解决了，因为人会交流。但是线程就不同了，线程可能会一直没完没了地“谦让”下去，
成为没有发生阻塞但依然执行不下去的“活锁”。

解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以。

3.所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。如果线程优先级“不均”，在cpu繁忙的情况下，优先级低的线程得到执行的机会
很小，就可能发生线程“饥饿”。持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。

解决饥饿的问题有三种方案:一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程时间过长。
因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行时间也很难缩短。方案二的使用场景相对
多一些。

那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓的公平锁，是指一种先来后到的方案，线程的
等待是有顺序的，排在等待队列前面的线程会优先获得资源。

### 08.管程:并发编程的钥匙

#### 1.什么是管程？

管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。

管程就是用来解决并发问题的。管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，
也能用信号量实现管程。但是管程更容易实现，java选择了管程。

管程的发展历史上，出现过三种不同的管程模型，分别是:Hasen模型，Hoare模型和MESA模型。

管程对应的英文名叫，Monitor“监视器”，操作系统一般都翻译“管程”。

#### 2. MESA模型？

1.java管程的实现参考的是MESA模型。并发编程，两个核心问题:互斥，同一时刻只允许一个线程访问共享资源。
同步，线程之间的如何通信、协作。

2.管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。

![](/images/posts/concurrent/3.png)

管程X将共享变量queue这个队列和相关的操作入队enq()、出队deq()都封装起来了。线程A和线程B想访问共享变量queue，
只能通过调用管程提供的enq()、deq()方法来实现。enq()、deq() 保证互斥性，只允许一个线程进入管程。

3.管程如何解决线程间的同步问题呢？（重点）

![](/images/posts/concurrent/4.png)

在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层框就代表封装的意思。框的上面只有一个入口，
并且在入口旁边还有一个入口等待队列。当前多个线程同时试图进入，只有一个线程进入，其它在入口等待队列中等待。

管程引入了条件变量，每个条件变量都对应一个等待队列，入图A和B。其实就是用来解决线程同步的。

假设线程T1执行出队操作，T1进入管程后发现队列是空的，去对应的条件变量等待队列等待。我们用对象A代表“队列不空”
这个条件，那么T1发现队列是空，就对象调用方法A.wait()，进入对应的等待队列。

假设线程T2执行入队操作，T1等待了，所以T2可以进入管程，执行入队操作。此时，“队列不空”这个条件满足了，那么T2需要
用A.notify()来通知A等待队列中的一个线程，此时这个等待队列里只有线程T1。至于notifyAll()方法，它可以通知对应的
等待队列中的所有线程。

这样我们就用条件变量来实现了线程间的同步了。

```java
public class BlockedQueue<T>{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满 
        notFull.await();
      }  
      // 省略入队操作...
      // 入队后, 通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      // 出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
```
这段代码中，await() 和前面我们提到的 wait() 语义是一样的，signal() 和前面我们提到的 notify() 语义一样。

4.管程里还引入了条件变量概念，每个条件变量都对应一个等待队列。

![](/images/posts/concurrent/5.png)

Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。
MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。

5.wait()方法的正确使用姿势？

对于MESA管程来说，有一个编程范式，就是需要在一个while循环里面调用wait()，这个是MESA管程持有的。

```java
while(条件不满足) {
  wait();
}
```


### 09.java的生命周期

java线程的生命周期可以简化为下图:

![](/images/posts/concurrent/6.png)

1.new Singleton()原本执行顺序

    a.分配一块内存
  
	b.在内存上初始化对象
  
	c.将地址赋给instance变量

1.RUNNABLE 与 BLOCKED 的状态转换

	a.synchronized修饰的方法、代码块同一时刻只允许一个线程执行，其它线程只能等待，等待的线程就会从RUNNABLE转换到BLOCKED状态。
	当获得锁，就会从BLOCKED转换到RUNNABLE状态。

	b.线程调用阻塞式API，操作系统层面线程会转换到休眠状态，jvm层面，还是RUNNABLE状态。因为在jvm看来，等待CPU使用权与等待I/O
	没有区别，都是在等某个资源，所以都归入RUNNABLE状态。

2.RUNNABLE 与 WAITING 的状态转换

	a.获得synchronized隐式锁线程，调用无参数的Object.wait()方法。

	b.调用无参数的Thread.join()方法，例如有一个线程对象 thread A，当调用 A.join 的时候，执行这条语句的线程会等待 thread A 执行
	完，而等待中的这个线程会进入WAITING。

	c.调用LockSupport.park()方法。

3.RUNNABLE 与 TIMED_WAITING 状态转换

	a.调用带超时参数Thread.sleep(long millis);

	b.获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；

	c.调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline)方法；

	d.调用带超时参数的 LockSupport.parkUnti(long deadline) 方法。

4.从 NEW 到 RUNNABLE 状态

	调用线程的start()方法

5.从 RUNNABLE 到 TERMINATED 状态

	a.线程执行完run()方法后，自动转换到 TERMINATED。

	b.调用 stop() （不建议使用）

	c.调用interrupt()

### 10.创建多少线程合适？

对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为
“CPU 核数 +1”。

对于 I/O 密集型计算场景，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]

### 11.为什么局部变量是线程安全的？



## 并发工具类


## 线程池


## 并发设计模式

## 按列分析

## 其他并发模型



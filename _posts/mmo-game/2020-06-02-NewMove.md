---
layout: post
title: 新版移动系统
categories: Mmo-Game
description: 新版移动系统
keywords: new，move
---

新版移动系统学习记录

**目录**

* TOC
{:toc}

## 整体结构

![](/images/posts/mmo_game/36.jpg)


## 类的继承关系

### 1.移动模块CharacterMoveModule继承关系

移动在游戏里是一个模块，不仅属于玩家，还属于npc等生物模块。

所以往上层逻辑放，不应改挂在actor下。

```java
/**
 * 生物基类 玩家、npc、宠物都继承与此基类 Created by wangqiang on 2017/7/6.
 */
public abstract class AbstractCharacter extends BPObject
{
     /**
     * 移动模块
     */
    private CharacterMoveModule moveModule = new CharacterMoveModule(this);

     /**
     * 命格模块
     */
    private PersonalityModule personalityModule = new PersonalityModule(this);

}
```
直接挂在生物基类AbstractCharacter下。


```java
/**
 * 抽象的模块基类,挂在character上的模块都需要继承此模块
 */
public abstract class AbstractCharacterModule implements ModuleInteface
{
    protected AbstractCharacter character;

}
```
挂在AbstractCharacter的module都需要继承模块基类AbstractCharacterModule，

AbstractCharacterModule抽象的模块基类最重要的是缓存了character引用。


```java
/**
 * 抽象的模块基类,挂在actor上的模块都需要继承此模块
 */
public abstract class AbstractActorModule extends AbstractCharacterModule
{
    public Actor getActor()
    {
        return actor;
    }
    
    /** 推送错误 */
    public void sendError(int code)
    {
    	actor.sendError(code);
    }

    /** 推送错误 */
    public void sendError(int code, int[] intParams, String[] strParams)
    {
    	actor.sendError(code, intParams, strParams);
    }

    /** 更改 */
    public void modified()
    {
        setModify(true);
    }

    /** 时间戳 */
    public long getNowTickTime()
    {
    	return actor.getNowTickTime();
    }

}
```
如果是仅属于玩家模块，AbstractCharacterModule派生一个玩家模块基类AbstractActorModule。

例如：背包，生活技能，货币，装备...

这些模块都需要上面几个常用的方法，获取actor,获取时间，推送错误，所以很有必要再抽象出一层，即AbstractActorModule。

移动模块不仅属于玩家，所以不是AbstractActorModule玩家模块的派生类。它应该和AbstractActorModule同级。


```java
/**
 * 移动模块
 *
 * <pre>
 *
 * 移动模式:
 *       - 特殊
 *       - 徘徊
 *       - 跳跃
 *       - 普通
 *              速度姿态  x  速度状态:
 *              - 站立       - 静止
 *              - 骑马       - 走
 *              - 游泳       - 跑
 *              - 载具       - 疾跑
 *                           - 冲刺
 *
 * </pre>
 *
 */
public class CharacterMoveModule extends AbstractCharacterModule
{
    /**
     * 当前移动模式 实例
     */
    private AbstractMoveMode curMoveMode;

     /**
     * 移动模式 实例组
     */
    private AbstractMoveMode[] moveModeArray = new AbstractMoveMode[MoveModeEnum.SIZE];

}
```
目前移动模块直接继承模块基类AbstractCharacterModule，没有再抽象一层。

CharacterMoveModule会对当前的移动模式curMoveMode进行tick,init()...，等等各种操作。

同时缓存了移动模式实例组，防止不停的new移动模式。


### 2.移动模式AbstractMoveMode类的继承关系

```java
/**
 * 移动模式的基类
 *
 */
public abstract class AbstractMoveMode
{
      /**
     * 移动模块引用
     */
    protected CharacterMoveModule moveModule;

      /**
     * 对应的移动模式枚举
     */
    public abstract MoveModeEnum getMoveModeEnum();

    /**
     * 初始化
     */
    public abstract void init();

    /**
     * 加载后处理
     */
    public void afterLoad()
    {
    }

     /**
     * tick
     */
    public abstract void tick(int interval);

}
```
缓存了移动模块引用，这里的tick, init...都是在CharacterMoveModule里调用。


```java
/**
 * 跳跃移动模式
 *
 */
public class MoveModeJump extends AbstractMoveMode
```

```java
/**
 * 移动模式 - 特殊移动
 *
 */
public class MoveModeSpecial extends AbstractMoveMode
```

```java
/**
 * 移动模式 - 徘徊
 *
 */
public class MoveModeWander extends AbstractMoveMode
```

```java
/**
 * 移动模式 - 普通
 *
 */
public class MoveModeNormal extends AbstractMoveMode
```
对应的各个移动模式，分别实现。

### 3.总结

CharacterMoveModule模块下，缓存一个当前的抽象的移动模式类，对当前移动模式进行tick等各种操作。

同时，借助工厂类创建当前移动模式。

也就是像我们的小游戏模块，玩家小游戏模块，缓存一个抽象的游戏逻辑操作类，每次对当前的游戏逻辑进行tick等各种操作，本质是一样的。

## CharacterMoveModule移动模块一些初始操作

### 1.init()

```java
MoveModeEnum[] values = MoveModeEnum.values();
for (MoveModeEnum moveModeEnum : values)
{
    AbstractMoveMode moveMode = MoveHelper.createMoveMode(moveModeEnum, this);
    if (moveMode == null)
    {
        BPLog.BP_LOGIC.error("【移动错误】移动模块初始化错误，创建移动模式实例错误 [moveModeEnum] {}", moveModeEnum);
        return;
    }

    if (moveMode.getMoveModeEnum() != moveModeEnum)
    {
        BPLog.BP_LOGIC.error("【移动错误】移动模块初始化错误，创建移动模式实例错误 [moveModeEnum] {}", moveModeEnum);
        return;
    }

    moveModeArray[moveModeEnum.getIndex()] = moveMode;
}

// 初始化上来先是普通移动
this.lastMoveModeEnum = DEFAULT_MOVE_MODE_ENUM;
this.curMoveModeEnum = DEFAULT_MOVE_MODE_ENUM;
this.curMoveMode = getMoveMode(DEFAULT_MOVE_MODE_ENUM);
this.curMoveMode.onEnterMode();
```
迭代移动模式枚举列表，MoveHelper.createMoveMode（）根据工厂模式创建对应的移动模式

缓存到实例组。

初始化上来是普通移动。


## 单位移动

### 1.客户端发送单位移动信息

```sh
required int32 index = 1; //单位序号(0:主角,1:宠物,2:傀儡,3:运镖车)
required int32 nowX = 2; //当前x坐标
required int32 nowY = 3; //当前y坐标
required int32 nowZ = 4; //当前z坐标
repeated int32 values = 5; //x,y,z坐标依次
optional bool nearBlock = 6; // 顶着墙行走(true为顶着墙行走，保持跑步状态)
optional int32 moveAttitude = 7; // 移动姿态
optional int32 moveState = 8; // 移动状态
optional int32 moveSeedType = 9; // 速度方式
optional bool needAcc = 10; // 是否加速
optional bool speedChange = 11; // 是否改变了速度
optional int32 passThroughParam = 12; // 透传参数
optional int32 jumpResumeSpeed = 13; // 跳跃落地接移动时的当前速度(只有跳跃落地接移动才发)
```

values = 5; //x,y,z 坐标依次，移动点组

moveState = 8; // 移动状态
```sh
STOP(0),                                        // 静止
WALK(1),                                        // 走
RUN(2),                                         // 跑
GALLOP(3),                                      // 疾跑
SPRINT(4),                                      // 冲刺
```

moveSeedType = 9; // 速度方式, 分为通用和战斗

根据前端上发的消息，服务端获取对应状态。

### 2.对客户端上发的路径点组做处理

```java
/**
* 客户端移动
*/
 public void clientMoveTo(...)
 {
      // 路径是否过长
        int movePathSize = moveList.size();
        if (movePathSize > CLT_MOVE_PATH_MAX)
        {
            moveList = moveList.subList(0, CLT_MOVE_PATH_MAX);
        }

         // 加工路径
        TIntArrayList pathListCahce = getAndClearPathListCache();
        CollectionUtils.addAll(pathListCahce,moveList);

 }
 ```
 路径过长，只截取最大的长度路径组CLT_MOVE_PATH_MAX = 32 * 3;

 为什么是32 * 3， 以什么为准则考虑的呢？



CollectionUtils.addAll()

```java
/**
    * 添加全部（jdk list 转为 trove4j list）
    * @param dst 目标 集合
    * @param src 源 集合
    */
public static void addAll(TIntArrayList dst,List<Integer> src)
{
    if(dst == null || src == null)
    {
        return;
    }

    if(src.isEmpty())
    {
        return;
    }

    //如果实现了随机访问接口，用循环遍历，效率高
    if(src instanceof RandomAccess)
    {
        for (int i = 0,iSize = src.size();i < iSize; i++)
        {
            Integer integer = src.get(i);
            if(integer == null)
            {
                continue;
            }
            dst.add(integer);
        }

        return;
    }

    //没有实现随机访问接口，采用迭代器遍历，效率高
    for(Iterator<Integer> iterator = src.iterator();iterator.hasNext();)
    {
        Integer integer = iterator.next();
        if(integer == null)
        {
            continue;
        }
        dst.add(integer);
    }
}

```
加工路径，jdk list 转为 trove4j list,防止频繁装箱拆箱。

如果实现了随机访问接口，用循环遍历，效率高。

没有实现随机访问接口，也就是类似链表顺序访问，采用迭代器遍历，效率高。

### 3.实际移动


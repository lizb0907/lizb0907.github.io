---
layout: post
title: 战斗
categories: Mmo-Game
description: mmo游戏里战斗代码学习
keywords: fight，mmo，game
---

战斗系统设计

**目录**

* TOC
{:toc}

## 类的继承关系

```java
/**
 * 抽象的模块基类,挂在character上的模块都需要继承此模块
 */
public abstract class AbstractCharacterModule implements ModuleInteface
{
    ...
    protected AbstractCharacter character;

    public AbstractCharacter getCharacter()
    {
        return character;
    }
    ...
}
```
挂在character上的模块都需要继承AbstractCharacterModule此模块，因为该模块存放着AbstractCharacter的引用，

我们通过getCharacter.getXXMoudle就可以拿到对应需要的挂在AbstractCharacter下的模块。

所以AbstractCharacterModule相当于一个中转站。


```java
/**
 * 技能模块基类
 */
public abstract class AbstractSkillModule extends AbstractCharacterModule
```
技能抽象模块基类需要继承AbstractCharacterModule，以便拿到对应需要的挂在AbstractCharacter下的模块。


```java
/**
 * 生物类的技能模块,是技能系统的基础,有逻辑也有数据
 */
public class CharacterSkillModule extends AbstractSkillModule
```
CharacterSkillModule继承技能模块基类，并且CharacterSkillModule需要挂在AbstractCharacter生物特性基类。


```java
/**
 * 生物基类 玩家、npc、宠物都继承与此基类 Created by wangqiang on 2017/7/6.
 */
public abstract class AbstractCharacter extends BPObject
{
    /**
     * 技能模块
     */
    protected CharacterSkillModule skillModule = new CharacterSkillModule(this);
}
```
CharacterSkillModule技能模块需要怪在生物基类下，因为不只玩家有技能，npc、侠客、宠物...都会有技能。

玩家，npc、侠客、宠物...都是生物，所以继承自生物特性基类AbstractCharacter。


## 技能和其它模块最相关是buff的派发，所以我们先看buff派发。

任务派发buff,场景事件派发buff，各种道具派发buff...

### 1.向目标发送一个效果,主要用于非技能模块的效果发送

```java
/**
* 向目标发送一个效果,主要用于技能模块的效果发送
*
* @param sender           效果的发送者
* @param receiver         效果接受者
* @param impactData       效果配置
* @param skillId          技能Id( * 没有填-1) ，可使用 {@link SkillCommonConstant#NO_SKILL_ID} 常量
* @param skillSign        技能标识 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_SIGN} 常量
* @param skillLevel       技能等级 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_LEVEL} 常量
* @param actualSkillLevel 效果步长,( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_ACTUAL_LEVEL} 常量
*/
public int sendImpactToForSkill(AbstractCharacter sender, AbstractCharacter receiver, DictStandardImpactData impactData, int skillId,int skillSign, int skillLevel,int actualSkillLevel)
{
    if (impactData == null)
    {
        return BPErrorCodeEnum.SKILL_SKILL_IMPACT_ID_IS_NOT_EXISTED;
    }

    return doSendImpactTo(sender, receiver, impactData,  skillId, skillSign,  skillLevel, actualSkillLevel);
}
```
向目标发送一个效果,主要用于技能模块的效果发送接口。

```java
/**
* 向目标效果
*
* @param sender           效果的发送者
* @param receiver         效果接受者
* @param impactData       效果配置
* @param skillId          技能Id( * 没有填-1) ，可使用 {@link SkillCommonConstant#NO_SKILL_ID} 常量
* @param skillSign        技能标识 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_SIGN} 常量
* @param skillLevel       技能等级 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_LEVEL} 常量
* @param actualSkillLevel 效果步长,( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_ACTUAL_LEVEL} 常量
* @return
*/
private int doSendImpactTo(AbstractCharacter sender, AbstractCharacter receiver, DictStandardImpactData impactData, int skillId,int skillSign, int skillLevel,int actualSkillLevel)
{
    ...
    // 判断能否施加效果
    int rs = canImpactTo(sender, receiver, impactData, actualSkillLevel);

    ...
    // 创建效果实例,例如无敌buff配的逻辑id为1，即持续性技能
    int impactLogicID = impactData.getLogicID();
    AbstractSkillImpact skillImpact = SkillHelper.createSkillImpact(impactLogicID, sender.getScene());

     //初始化buff时长，根据StandardImpact表里配置durationTimeSpecial时长
    skillImpact.init(sender.getObjectID(), receiver,impactData);
    ...

    //计算buff时长,其它修改引起修正
    skillImpact.calcBuffTime(receiver, sender);

    ...
    // 派发逻辑
    int receiveRS = receiver.getSkillModule().receivedImpact(skillImpact);

}
```
列举了些重要的处理，buff时长读表，派发逻辑receivedImpact

```java
/**
* 接收一个impact效果
*
* @param skillImpact
* @return
*/
public int receivedImpact(AbstractSkillImpact skillImpact)
{
    ...
     // 能否接受效果检测
    int canRs = canReceiveImpact(skillImpact);
    if(canRs < 0)
    {
        return canRs;
    }
    ...

    // 处理互斥
    int rs = dealImpactMutexAndRepeat(skillImpact);
    if (rs < 0)
    {
        return rs;
    }
    ...
}
```
能否接受效果检测,例如：之前上了一个增益类型的buff无敌，那么此时接收一个负面类的buff不通过。

处理互斥,走表配置。

```sh
1.非持续性不处理互斥。

2.来源于同一个单位的同一BUFF组的叠加规则：（可叠加的BUFF在层数满之后只刷新BUFF时间）
    0:替换，互斥优先级低的无法替换高级的
    1:刷新BUFF时间（刷新BUFF时间的效果不会充值周期触发效果的周期循环）
    2:添加不影响现有
    3:无法添加新BUFF
（前两种情况下，BUFF等级低于目标身上同组BUFF等级的无法生效）

3.不同源BUFF叠加规则:
    0:直接替换（低级BUFF不可替换高级的）
    1:刷新BUFF时间（同等级BUFF刷新BUFF时间，BUFF来源不变，高级的BUFF覆盖低级的，BUFF来源改为高级BUFF的施加者）
    2:各自添加不互相影响
```

![](/images/posts/mmo_game/13.jpg)
```sh
现在无敌buff配的是，互斥组配的是1也就是自身互斥，同源叠加规则配的是0，即替换。

那么假设同时给自身上两个无敌buff，第一个无敌buff直接被第二个无敌buff替换掉。

```

```java
/**
    * 处理BUFF的互斥
    * @param mutexType 互斥类型
    * @param buff      身上的BUFF
    * @param addImpact 要添加的BUFF效果
    * @return
    */
private int doMutexImpact(int mutexType,AbstractSkillImpact buff,AbstractSkillImpact addImpact)
{
    ...
    ...
     else
    {
        // 中断互斥顶替掉的buff
        buff.onBeMutexBreeak(getCharacter(),addImpact);
        buff.breakImpact(getCharacter());

        return 0;
    }
    ...
    ...
}
```
同时给自身上两个无敌buff，可以根据配置规则让第一个无敌buff直接被第二个无敌buff替换掉。

需要先调用breakImpact(AbstractCharacter character)中断第一个buff效果。

然后将新来的无敌buff添加到buff列表里。

## 技能系统图示

技能系统服务器客户端流程:

![](/images/posts/mmo_game/21.png)

技能系统控制流程抽象:

![](/images/posts/mmo_game/22.png)

## 技能释放流程

### 1.前端使用技能请求

```java
// 使用技能请求
message CSUseSkillRequest{//20300
	required int32 skillID = 1; // 技能id
	required int32 targetObjectID = 2; // 选择的目标id
	required int32 rotation = 3; // 朝向, 传0->360
	required int32 sign = 4; // 技能标识
	required int32 type = 5; // 类型:0玩家 1宠物 2傀儡 3侠客
	optional int32 dummyObjectID = 6; // 傀儡ObjectID(用于傀儡释放技能);当type为3时,该值为侠客的KnightID
	repeated int32 paths = 7; //x,y,z坐标结合(位移技能路径)
	repeated int32 hitPoints = 8; // x,y,z生效的打击点坐标集合(目前主要给侠客大招使用)
	optional bool isStandalone = 9; // 是否是单机释放技能(目前主要给侠客大招使用)
}
```

### 2.玩家技能释放

目前版本很多废弃了，例如：宠物、轻功，所以我们直接从玩家技能释放开始看。

```java
/**
* 玩家使用技能
*
* @param message
* @param response
* @param actor
* @param isStandalone 是否是单机释放
*/
private void acoterUseSkill(BPFight.CSUseSkillRequest message, BPFight.SCUseSkillResponse.Builder response,
                            Actor actor,boolean isManualMoveSkill, boolean isStandalone)
{
    ...
    ...
    //旧的目标
    int lastTargetID = actor.getAbstractCharacterCommonModule().getTargetObjectID();
    //旧的朝向
    int lastRotation = actor.getRotation();

    //技能id
    int skillID = message.getSkillID();
    //目标id
    int targetID = message.getTargetObjectID();
    //技能标识
    int skillSign = message.getSign();
    ...
    ...

    //检测是否坐骑，坐骑不能使用技能

    //检测变身后能否使用技能

    //检查移动状态能否使用技能

    //设置客户端上传的最新目标和朝向

    //调用useSkill
    result = actor.getSkillModule().useSkill(actor, skillID, skillSign, isStandalone, true);

    //设置技能使用响应客户端

    //技能使用事件

    //客户端使用技能成功广播
}
```

```java
/**
* 使用技能
*
* @param character 使用者
* @param skillID   技能id
* @param sign      技能标识(客户端释放时指定，服务器主动释放填-1,内部会自动生成)
* @param isStandalone 是否是单机释放
* @param cltUse    是否客户端释放
* @return
*/
public int useSkill(AbstractCharacter character, int skillID, int sign, boolean isStandalone, boolean cltUse)
{
    //检查当前场景能否使用技能

    //是否正在使用技能
    boolean isContinuityUse = isUsingSkill();

    //根据技能id获取，技能模板表、技能编辑表、技能数据表数据

    //根据技能模板表，检查是否释放被动技能错误
    if (!skillTemplate.isActive())
    {
        return BPErrorCodeEnum.SKILL_USE_PASSIVE_SKILL_USE_REPEAT;
    }

    // 获取技能组
    DictSkillGroupData skillGroup = null;
    if (skillTemplate.getSkillGroupType() > 0)
    {
        skillGroup = (DictSkillGroupData) DictSkillGroupData.getRecordById(skillTemplate.getSkillGroupType());
        if (skillGroup == null)
        {
            return BPErrorCodeEnum.SKILL_SKILL_GROUP_NOT_MATCH;
        }
    }

    // 如果当前正在使用技能
    if(isContinuityUse)
    {
        //如果当前正在使用技能，做一个临时缓存
        tempSkillInfo.copyFrom(skillInfo);
    }

    //设置当前技能释放的技能信息
    skillInfo.setSkillGroup(skillGroup);
    skillInfo.setSkillEditorData(skillEditorData);
    skillInfo.setSkillData(skillData);
    skillInfo.setSkillTemplate(skillTemplate);

    // 检测技能使用条件（传入是否客户端释放）
    // 检查cd、消耗、技能组和单体技能检测、位移、自身、目标。
    int result = checkUseSkill(cltUse);

    ...

    // 连携释放，先打断当前技能（正在使用当前技能）
    if(isContinuityUse)
    {
        // 必须先将skillInfo设置回当前技能的，再进行中断操作
        skillInfo.copyFrom(tempSkillInfo);
        tempSkillInfo.clear();

        // 中断当前技能
        doFinishCurrentSkillLogic(true,true);

        // 再将skillInfo设置回要使用的技能
        skillInfo.setSkillGroup(skillGroup);
        skillInfo.setSkillEditorData(skillEditorData);
        skillInfo.setSkillData(skillData);
        skillInfo.setSkillTemplate(skillTemplate);
    }

    // 创建技能逻辑实例
    result = createSkillLogic(character, skillTemplate);
    if (result != 0)
    {
        // 创建技能逻辑失败,返回错误码
        return result;
    }

    // 扣除消耗
    skillConsume();

    // 激活技能逻辑,开始tick
    currentSkillLogic.init();
    currentSkillLogic.setSkillId(skillTemplate.getId());
    currentSkillLogic.setSkillSign(sign);
    currentSkillLogic.setClientUse(cltUse);
    currentSkillLogic.setSkillModule(this);
    currentSkillLogic.setActualSkillLevel(actualSkillLevel);

    // 增加cd时间
    addCooldownForCurrentSkillLogic();

    // 将预使用技能主动位移路径设置到当前使用技能路径中
    if(skillEditorData.getChaseNum() > 0)
    {
        if(cltUse)
        {
            setAllChasePath(this.prepareUseChasePath);
        }
        else
        {
            preCalcChasePath(skillEditorData,this.chasePath);
        }
    }
    
    ...

    // 技能使用事件
    ...

}
```

检查当前场景能否使用技能。

根据技能id获取，技能模板表、技能编辑表、技能数据表数据。

根据技能模板表，检查是否释放被动技能错误。

根据技能模板表获取技能组。

如果当前正在使用技能，将当前使用的技能信息做一个临时缓存。

设置当前技能释放的技能信息。

检测技能使用条件（传入是否客户端释放）。检查cd、消耗、技能组和单体技能检测、位移、自身、目标。

连携释放，先打断当前技能（正在使用当前技能）。

创建技能逻辑实例。

扣除消耗。

激活技能逻辑,开始tick。

增加cd时间。

将预使用技能主动位移路径设置到当前使用技能路径中。

技能使用事件（切换战斗状态...）。

### 3.玩家技能释放过程各个方法调用

#### 1.检查cd、消耗、技能组和单体技能检测、位移、自身、目标

```java
* 使用技能检测
*
* @param isCltUse 是否客户端使用
*/
@Override
public int checkUseSkill(boolean isCltUse)
{
    // 此技能是否CD
    int result = checkCooldown(skillTemplate,skillData);

    ...

     // 检测消耗
    result = checkConsume();

    ...

    // 检测技能释放位移
    if(isCltUse)
    {
        // 客户端释放的检测客户端发来的位移点
        result = checkChase(skillEditorData,prepareUseChasePath);
        if (result != 0)
        {
            clearPrepareUseChasePath();
            return result;
        }
    }
    else
    {
        // 服务器释放的检测 冲向瞄准目标的位移类型是否有瞄准目标
        result = checkChaseAim(skillEditorData);
        if (result != 0)
        {
            return result;
        }
    }

    ...
    // 检测自身条件
    result = checkSelf();

    ...
    // 选择目标检测
    result = checkTarget();

}
```

##### 1.检查技能是否在冷却(也检查公共冷却),根据技能模板表配置skillTemplate

// 此技能是否CD
int result = checkCooldown(skillTemplate,skillData);

/**
* 检查技能是否在冷却(也检查公共冷却)
*/
public int checkCooldown(DictSkillTemplate skillTemplate,DictSkillDataData skillData)
{
    //commonCoolDownRemian公共冷却时间优先级最大，类似：放了一个大招导致某段时间内所有技能都不能使用的情况。
    if(skillTemplate.getIsCommonCD() == 1 && commonCoolDownRemian > 0)
    {
        return BPErrorCodeEnum.SKILL_IN_COOLDOWN;
    }

    ...
}

根据skillTemplate表配置的检测是否受公共冷却影响。

检查表配置的冷却id是否大于0。

迭代缓存的冷却的列表，检测当前的技能是否冷却完毕。

##### 2.检测消耗（只是检测不扣除，根据DictSkillDataData表）

 // 检测消耗
result = checkConsume();

```java
**
* 检查技能消耗
*
* @param character     角色类
* @param skillTemplate 技能主表
* @param skillData     技能效果表
* @param skillGroup    技能组
* @return <0 不够消耗的理由  =0足够消耗
*/
public static int checkConsume(AbstractCharacter character, DictSkillTemplateData skillTemplate, DictSkillDataData skillData, DictSkillGroupData skillGroup)
{
    //DictSkillDataData表里配置的节能消耗类型有两列：conditionLogicID_0和conditionLogicID_1
    for(int i = 0 , size =  skillData.getConditionCount(); i < size; i++)
    {
        SkillConsumeTypeEnum consumeType = skillData.getConditions()[i];
        if (consumeType == null)
        {
            continue;
        }
        int valueBase = skillData.getConditionConsumeBases()[i];

        // 计算一次消耗
        int value;
        // 根据类型扣除数值
        switch (consumeType)
        {
          case CONSUME_HP_VALUE:
                case CONDITION_HP_VALUE:
                {
                    int need = valueBase;
                    value = character.getAttributeLogic().getAttribute(AttributeTypeEnum.HP);
                    if (value < need)
                    {
                        return BPErrorCodeEnum.SKILL_USE_SKILL_HP_NOT_ENOUGH;
                    }
                    break;
                }
            ...
            ...
        }

        ...
        ...
    }
    
}
```
根据DictSkillDataData表配置，只检测没有扣除。

##### 3.客户端使用技能位移检测（SkillDataEditorData技能编辑表）

```java
/**
* 检查技能位移使用
* @param dict
* @return
*/
private int checkChase(DictSkillDataEditorData dict,TIntArrayList pathList)
{
    // 检查主动位移, SkillDataEditor技能编辑表里配置的chaseLength_0、chaseLength_1...chaseLength_20
    // 表里配置的主动位移大于0，那么chaseNum数量累加
    int configChaseNum = dict.getChaseNum();
    if(configChaseNum <= 0)
    {
        return 0;
    }

    // 客户端上发的路径是否为空
    if(CollectionUtils.isBlank(pathList))
    {
        return BPErrorCodeEnum.SKILL_MANUAL_MOVE_SKILL_NO_PATH;
    }
    int pathSize = pathList.size();

    //校验客户端发上来的路径段数是否与表里配置主动位移路段数一致
    //客户端上发的是xyz
    if(pathSize != configChaseNum * 3)
    {
        return BPErrorCodeEnum.SKILL_MANUAL_MOVE_SKILL_PATH_PARAM_ERROR;
    }
    //取最后路径的X坐标
    int finalX = pathList.get(pathSize-3);
    //取最后路径的Z坐标
    int finalZ = pathList.get(pathSize-1);

    // 判断终点是否是阻挡区域
    boolean bolckFlag = getCharacter().getScene().getSceneGirdModule().checkWalkableForClientMove(finalX,finalZ);
    if(!bolckFlag)
    {
        if(BPGlobals.getInstance().isDebugVersion())
        {
            // TODO 修改日志级别，适应压测。压测后重新改成warn日志
            BPLog.BP_FIGHT.debug("【主动位移技能错误】客户端发来的位置是阻挡 [objectID] {} [skillID] {} [pos] ({},{})"
                    , character.getObjectID(), dict.getId(), finalX,finalZ);
        }
        return BPErrorCodeEnum.SKILL_MANUAL_MOVE_DESTINATION_BLOCK;
    }

    ...

    // 校验距离是不是过大
    int[] chaseLengths = dict.getChaseLengths();
    int index = 0;
    //注意这里是将值赋给了临时变量pre，数组才会是地址
    int preX = character.getX();
    int preZ = character.getZ();
    for (int i = 0; i < chaseLengths.length; i++)
    {
        //依次拿出每次移动的值
        int chaseLength = chaseLengths[i];
        if(chaseLength <= 0)
        {
            continue;
        }

        // 增加3米容错
        chaseLength += 300;

        int lengthSQ = chaseLength * chaseLength;

        int x =  pathList.get(index * 3);
        int z =  pathList.get(index * 3 + 2);
        //下一次循环preX,preZ是当前的最新值
        float disSQ = MapUtils.distanceSqBetweenPos(preX, preZ, x, z);

        if(disSQ > lengthSQ)
        {
            if(BPGlobals.getInstance().isDebugVersion())
            {
                // TODO 修改日志级别，适应压测。压测后重新改成warn日志
                BPLog.BP_FIGHT.debug("【主动位移技能错误】客户端发来的位移距离超过技能配置最大距离限制 [objectID] {} [skillID] {} [派发次数] {} [实际距离] {} [最大距离] {}"
                        , character.getObjectID(), dict.getId(), i + 1, (int)Math.sqrt(disSQ),chaseLengths[i]);
            }
            //主动位移类技能的目的地超过范围
            return BPErrorCodeEnum.SKILL_MANUAL_MOVE_SKILL_DESTINATION_TOO_FAR;
        }

        preX = x;
        preZ = z;
        index++;

        if(index >= configChaseNum)
        {
            break;
        }
    }

    ...

}
```
SkillDataEditor技能编辑表里配置的chaseLength_0、chaseLength_1...chaseLength_20,校验当前技能位移是否合法。

例如袁天罡有些技能是带位移的，那么表里配置的chaseLength值会大于0。客户端在请求使用技能时会发送技能的路径点组到服务端。

服务端会校验路径点组长度是否和表里配置的长度相等。并校验终点坐标的是否阻挡区域。

校验客户端上发的点组移动距离是不是和配置的表距离过大。


##### 4.服务端自身使用技能位移检测（SkillDataEditorData技能编辑表）

```java
/**
* 检测服务器释放的技能，是否有冲向目标的技能
* @param skillDataEditorData
* @return
*/
private int checkChaseAim(DictSkillDataEditorData skillDataEditorData)
{
    //表配置不用校验安全距离
    if(!skillDataEditorData.isChaseLockTarget())
    {
        return 0;
    }

    AbstractCharacter character = getCharacter();
    //当前瞄准的目标object id
    int aimObjectID = character.getAbstractCharacterCommonModule().getAimObjectID();
    if(aimObjectID < 0)
    {
        if(BPGlobals.getInstance().isDebugVersion())
        {
            // TODO 修改日志级别，适应压测。压测后重新改成warn日志
            BPLog.BP_FIGHT.debug("【技能释放错误】首段位移是冲向瞄准目标的技能，释放的时候没有设置瞄准目标 [objectId] {} [objectType] {} [skllId] {}",
                    character.getObjectID(),character.getObjectType().name(),skillDataEditorData.getId());
        }
        //服务器使用的冲向目标技能没有设置瞄准目标
        return BPErrorCodeEnum.SKILL_CHASE_SERVER_USE_NO_AIM_OBJECT;
    }

    return 0;
}
```
表配置是否校验安全距离。

服务器释放技能必须有当前瞄准的目标object id。

##### 5.检测自身条件

```java
/**
* 技能释放检查自身条件是否满足
*
* @return
*/
public int checkSelf()
{
    DictSkillTemplateData skillTemplate = skillInfo.getSkillTemplate();
    DictSkillDataData skillData = skillInfo.getSkillData();
    ...
    ...

     // 是否携带条件BUFF
    int buffRs = checkConditionBuff(skillTemplate);
    if(buffRs < 0)
    {
        return buffRs;
    }

    // 是否受限于BUFF
    buffRs = checkLimitBuff(skillTemplate);
    if (buffRs < 0)
    {
        return buffRs;
    }

}
```
是否禁止释放技能

自己是否活着

受身技能的释放限制

是否在移动中(正常移动和特殊移动)

如果正在使用轻功

正在使用绝学

跳跃中

当前等级小于技能需要的最低等级

检测当前玩家身上挂有需要的buff。

是否有控制该技能释放的BUFF,中buff了有些技能不用。

检查玩家特殊条件,变身和读条。



##### 6.技能选择目标检测

```java
/**
* 技能释放目标检测
*
* @return
*/
public int checkTarget()
{
    ...
    ...
    // AOE 不选敌
    boolean isAOE = SkillHelper.isAOE(skillEditorData);
    if (isAOE)
    {
        if(!skillEditorData.isLockTargetFirstOnAOE())
        {
            // AOE不优先索敌目标则清空目标
            character.getAbstractCharacterCommonModule().setTargetObjectID(SkillCommonConstant.TARGET_ID_NONE);
        }
        return 0;
    }

    // 如果技能目标是自己，就将自己设置为目标
    if (skillTemplate.getEffectTargetEnum() == SkillEffectTargetEnum.SELF)
    {
        character.getAbstractCharacterCommonModule().setTargetObjectID(character.getObjectID());
        return 0;
    }
    ...
    ...
}
```
这里如果当前技能是aoe技能，则清空目标。


如果技能目标是自己，就将自己设置为目标。

#### 2.连携释放，先打断当前技能（正在使用当前技能）

```java
**
* 技能结束
* @param isBreak     是否中断
* @param isSelfBreak 是否自己主动中断(例如连携释放新技能中断当前技能)
*/
private void doFinishCurrentSkillLogic(boolean isBreak, boolean isSelfBreak)
{
    //各种清空

    //打断通知客户端
}
```

#### 3.创建技能逻辑实例

// 创建技能逻辑实例(现在去掉所有的技能逻辑，只保留17号技能逻辑)
result = createSkillLogic(character, skillTemplate);

```java
/**
* 创建技能逻辑实例,之创建出logic类
*
* @param skillTemplate
* @param skillData
* @param scene         当前所在场景
* @return
*/
public static AbstractSkillLogic createSkillLogic(DictSkillTemplateData skillTemplate, DictSkillDataEditorData dictSkillDataEditorData,DictSkillDataData skillData, AbstractBPScene scene)
{
    ...
    ...
    AbstractSkillLogic skillLogic = scene.getSkillCache().createSkillLogic(17);
    if (skillLogic != null)
    {
        SkillLogicTypeEnum logicTypeEnum = skillTemplate.getLogicTypeEnum();
        //设置技能逻辑类型(顺发，引导，持续,特殊逻辑控制)
        skillLogic.setLogicType(logicTypeEnum);
        skillLogic.setDictSkillTemplateData(skillTemplate);
        skillLogic.setDictSkillDataEditorData(dictSkillDataEditorData);
        skillLogic.setDictSkillDataData(skillData);
    }
    ...
    ...s
}
```
创建技能逻辑类，设置技能逻辑类型(顺发，引导，持续,特殊逻辑控制)

#### 4.扣除消耗(实际扣除消耗)

```java
/**
* 扣除技能消耗
*
* @return
*/
private int skillConsume()
{
    //DictSkillDataData表里配置的节能消耗类型有两列：conditionLogicID_0和conditionLogicID_1
    for(int i = 0 , size =  skillData.getConditionCount(); i < size; i++)
    {
        SkillConsumeTypeEnum consumeType = skillData.getConditions()[i];
        if (consumeType == null)
        {
            continue;
        }
        int valueBase = skillData.getConditionConsumeBases()[i];

        // 计算一次消耗
        int value;
        // 根据类型扣除数值
        switch (consumeType)
        {
            case CONSUME_HP_VALUE:
            {
                int need = valueBase;
                character.getAttributeLogic().minusOneAttribute(AttributeTypeEnum.HP, need);
                break;
            }
            ...
            ...
        }

        ...
        ...
    }

}
```
DictSkillDataData表里配置的节能消耗类型有两列：conditionLogicID_0和conditionLogicID_1

根据表配置扣除消耗，实际扣除了！

#### 5.技能标识

```java
// 技能sign
if (sign <= 0)
{
    // 如果释放技能时没有sign,则主动生成一个sign
    sign = getAndIncreaseSkillSign();
}
```

```java
/**
* 计算当前技能的技能标识
*
* @return
*/
private int getAndIncreaseSkillSign()
{
    //技能标识,主要发送给客户端用于前端伤害识别、技能效果匹配等用途
    skillSignCounter++;
    // 防止有0，客户端要求skill_sign不能为0，所以加1
    return (skillSignCounter & SkillCommonConstant.SKILL_SIGN_MOD) + 1;
}
```

#### 6.激活技能逻辑,开始tick

```java
// 激活技能逻辑,开始tick
currentSkillLogic.init();
currentSkillLogic.setSkillId(skillTemplate.getId());
currentSkillLogic.setSkillSign(sign);
currentSkillLogic.setClientUse(cltUse);
currentSkillLogic.setSkillModule(this);
currentSkillLogic.setActualSkillLevel(actualSkillLevel);
```

当前技能逻辑类的一些初始化。

#### 7.增加cd时间

// 增加cd时间
addCooldownForCurrentSkillLogic();

#### 8.将预使用技能主动位移路径设置到当前使用技能路径中

```java
if(skillEditorData.getChaseNum() > 0)
{
    if(cltUse)
    {
        setAllChasePath(this.prepareUseChasePath);
    }
    else
    {
        preCalcChasePath(skillEditorData,this.chasePath);
    }
}
```

#### 9.使用技能事件,清楚相关身上的buff

// 使用技能事件,清楚相关身上的buff
onStatChange(character, SkillStateChangeEnum.START_ATTACK);

```java
/**
* 相关状态变化时调用
*
* @param sender 发生变化的发送者。
*               比如玩家受击，sender为发出攻击的玩家
*               切换场景由于是玩家自己主动驱动，所以sender为玩家自己
*               1：下线
*               2：切换场景
*               3：开始移动
*               4：玩家受到伤害
*               5: 开始攻击
*/
public void onStatChange(AbstractCharacter sender, SkillStateChangeEnum stateChangeEnum)
{
    ...
    ...
    switch (stateChangeEnum)
    {
        case START_MOVE:
        {
            if (currentSkillLogic != null)
            {
                currentSkillLogic.onStartMove(sender);
            }
            int size = buffList.size();
            for (int i = 0; i < size; i++)
            {
                AbstractSkillImpact impact = buffList.get(i);
                impact.onStartMove(sender);
            }
            break;
        }
        ...
        ...
    }
}
```
使用技能就会调用onStatchange,然后迭代玩家身上所有的效果，根据standardimpact表配置使用技能是否打断buff列状态来判断是否打断。

```java
/**
*  中断效果
* (非计时结束导致的buff结束，都要调用buff中断结束)
* @param character
* @param canBreakDispel 是否能驱散 不可驱散 特性BUFF| true = 能驱散不可驱散buff   false = 不可驱散buff不能被驱散
*/
private void doBreakImpact(AbstractCharacter character,boolean canBreakDispel)
{
    if (isFinished)
    {
        return;
    }

    //如果不是持续性buff效果，直接返回
    if(impactData.getImpactType() != SkillImpactTypeEnum.PERSISTENT.getValue())
    {
        return;
    }

    //传入不是驱散， 并且当前buff表里配置不能被中断
    if(!canBreakDispel && !getImpactData().isBeDispel())
    {
        return;
    }

     // notice client,
    // 效果已经激活并且不是位移效果打断
    if (isActive() && !isBeBreakBeatBackImpact())
    {
    }
    
    ...
    ...
}
```

中断效果。是否通知并选择通知类型。


#### 10.根据释放技能事件，处理相应的buff逻辑

```java
private void onUseSkill(DictSkillTemplateData skillTemplate)
{
    // 释放技能事件
    handleBuffEventOnBatch(BuffListenEventEnum.EVENT_TYPE_USE_SKILL,skillTemplate.getId(),0,0,0,0,0,0,0,null,null);
}
```
释放技能事件，传入释放技能枚举和技能id。


```java
/**
* 批量处理处理监听buff事件
* @param eventEnum
* @param intParam0
* @param intParam1
* @param intParam2
* @param intParam3
* @param intParam4
* @param intParam5
* @param longParam0
* @param longParam1
* @param objectParam0
* @param objectParam1
*/
public void handleBuffEventOnBatch(BuffListenEventEnum eventEnum,int intParam0, int intParam1, int intParam2, int intParam3, int intParam4, int intParam5, long longParam0, long longParam1, Object objectParam0, Object objectParam1)
{
    //传入的枚举为释放技能
    List<AbstractSkillImpact> listenBuffList = getEventListenBuffsByEvent(eventEnum.getType());
    if(!CollectionUtils.isBlank(listenBuffList))
    {
        for (int i = 0,iSize = listenBuffList.size(); i < iSize; i++)
        {
            listenBuffList.get(i).handleEvent(eventEnum,character, intParam0, intParam1, intParam2, intParam3, intParam4, intParam5, longParam0, longParam1, objectParam0, objectParam1);
        }
    }
    ...
    ...
}
```
根据释放技能枚举，获取所有与释放技能有关的buff列表，迭代列表依次处理逻辑。


```java
/**
* 为效果注册到BUFF事件监听
*
* @param toAddImpact
*/
public void registeToEventListenMap(AbstractSkillImpact toAddImpact)
{
    ...
    //不是持续性，返回
    if (toAddImpact.getImpactData().getImpactType() != SkillImpactTypeEnum.PERSISTENT.getValue())
    {
        return;
    }

    //获取当前buff的事件集合, 例如46号技能效果buff,监听血量上限会有多个事件，所以是事件组
    BuffEventHandleEnum[] events = toAddImpact.getBuffEventHandles();
    if (events == null || events.length < 1)
    {
        return;
    }

    OUTER_LOOP:
    for(int i = 0 , size =  events.length; i < size; i++)
    {
        //BUFF事件监听处理类型
        BuffEventHandleEnum event = events[i];
        if (event.getType() < 0)
        {
            continue;
        }

        //根据事件类型加入到  BUFF事件监听map
        ArrayList<AbstractSkillImpact> listenImpacts = eventListenMap.get(event.getType());
        ...
    }
    ...
}
```
每个buff都有它关心的事件类型，每个buff在初始化和添加时，会根据类型注册到缓存。

例如buff如果和释放技能事件有关，那么释放技能时需要处理对应buff逻辑。

#### 11.切换战斗状态


```java
/**
* 使用技能
*/
public void onSkillUse()
{
    isUseSkill = true;
    lastFightInterval = 0;
    if(!this.isFightStatus)
    {
        switchFightStatus(true);
    }
}
```
使用技能，切换战斗状态

### 4.tick当前技能逻辑

@Override
public void tickSkillLogic(int interval)
{
    if (currentSkillLogic == null)
    {
        lastSkillEndInterval += interval;
        return;
    }

    currentSkillLogic.tick(interval);

    if (currentSkillLogic.isFinished())
    {
        BPLog.BP_FIGHT.debug("技能结束, id:{}", currentSkillLogic.getSkillID());

        // 结束技能
        boolean isBreak = currentSkillLogic.isBreak();

        doFinishCurrentSkillLogic(isBreak,false);

        return;
    }
}

#### 5.激活后会进行tick

```java
/**
* 激活后会进行tick
*
* @param interval
*/
public void tick(int interval)
{
    ...
    ...
    if (!isActive)
    {
        //初始化是否AOI
        //根据skillDataEditor表配置的技能打击形状判断是否AOE
        //初始化持续时间
        //初始化延迟生效时间
        onActivate();
        interval = 0;
        isActive = true;
    }
    ...
    ...
     // 判断血量大于零
    if (!isHpPositive())
    {
        breakSkill();
        return;
    }
    ...

    // tick技能逻辑
    tickSkillLogic(interval);
    ...
}
```

初始化是否AOI

根据skillDataEditor表配置的技能打击形状判断是否AOE

初始化持续时间

初始化延迟生效时间

tick技能逻辑

##### 1.瞬发技能的tick处理

```java
/**
* 瞬发技能的tick处理
*
* @param interval
*/
public void tickInstantSkillLogic(int interval)
{
    if (!isTakeEffect)
    {
        startEffect();
        //是否生效
        isTakeEffect = true;
    }
}
```
技能开始生效。


---
layout: post
title: 战斗
categories: Mmo-Game
description: mmo游戏里战斗代码学习
keywords: fight，mmo，game
---

战斗系统设计

**目录**

* TOC
{:toc}

## 类的继承关系

```java
/**
 * 抽象的模块基类,挂在character上的模块都需要继承此模块
 */
public abstract class AbstractCharacterModule implements ModuleInteface
{
    ...
    protected AbstractCharacter character;

    public AbstractCharacter getCharacter()
    {
        return character;
    }
    ...
}
```
挂在character上的模块都需要继承AbstractCharacterModule此模块，因为该模块存放着AbstractCharacter的引用，

我们通过getCharacter.getXXMoudle就可以拿到对应需要的挂在AbstractCharacter下的模块。

所以AbstractCharacterModule相当于一个中转站。


```java
/**
 * 技能模块基类
 */
public abstract class AbstractSkillModule extends AbstractCharacterModule
```
技能抽象模块基类需要继承AbstractCharacterModule，以便拿到对应需要的挂在AbstractCharacter下的模块。


```java
/**
 * 生物类的技能模块,是技能系统的基础,有逻辑也有数据
 */
public class CharacterSkillModule extends AbstractSkillModule
```
CharacterSkillModule继承技能模块基类，并且CharacterSkillModule需要挂在AbstractCharacter生物特性基类。


```java
/**
 * 生物基类 玩家、npc、宠物都继承与此基类 Created by wangqiang on 2017/7/6.
 */
public abstract class AbstractCharacter extends BPObject
{
    /**
     * 技能模块
     */
    protected CharacterSkillModule skillModule = new CharacterSkillModule(this);
}
```
CharacterSkillModule技能模块需要怪在生物基类下，因为不只玩家有技能，npc、侠客、宠物...都会有技能。

玩家，npc、侠客、宠物...都是生物，所以继承自生物特性基类AbstractCharacter。


## 技能和其它模块最相关是buff的派发，所以我们先看buff派发。

任务派发buff,场景事件派发buff，各种道具派发buff...

### 1.向目标发送一个效果,主要用于非技能模块的效果发送

```java
/**
* 向目标发送一个效果,主要用于技能模块的效果发送
*
* @param sender           效果的发送者
* @param receiver         效果接受者
* @param impactData       效果配置
* @param skillId          技能Id( * 没有填-1) ，可使用 {@link SkillCommonConstant#NO_SKILL_ID} 常量
* @param skillSign        技能标识 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_SIGN} 常量
* @param skillLevel       技能等级 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_LEVEL} 常量
* @param actualSkillLevel 效果步长,( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_ACTUAL_LEVEL} 常量
*/
public int sendImpactToForSkill(AbstractCharacter sender, AbstractCharacter receiver, DictStandardImpactData impactData, int skillId,int skillSign, int skillLevel,int actualSkillLevel)
{
    if (impactData == null)
    {
        return BPErrorCodeEnum.SKILL_SKILL_IMPACT_ID_IS_NOT_EXISTED;
    }

    return doSendImpactTo(sender, receiver, impactData,  skillId, skillSign,  skillLevel, actualSkillLevel);
}
```
向目标发送一个效果,主要用于技能模块的效果发送接口。

```java
/**
* 向目标效果
*
* @param sender           效果的发送者
* @param receiver         效果接受者
* @param impactData       效果配置
* @param skillId          技能Id( * 没有填-1) ，可使用 {@link SkillCommonConstant#NO_SKILL_ID} 常量
* @param skillSign        技能标识 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_SIGN} 常量
* @param skillLevel       技能等级 ( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_LEVEL} 常量
* @param actualSkillLevel 效果步长,( * 没有填 0)，可使用 {@link SkillCommonConstant#NO_SKILL_ACTUAL_LEVEL} 常量
* @return
*/
private int doSendImpactTo(AbstractCharacter sender, AbstractCharacter receiver, DictStandardImpactData impactData, int skillId,int skillSign, int skillLevel,int actualSkillLevel)
{
    ...
    // 判断能否施加效果
    int rs = canImpactTo(sender, receiver, impactData, actualSkillLevel);

    ...
    // 创建效果实例,例如无敌buff配的逻辑id为1，即持续性技能
    int impactLogicID = impactData.getLogicID();
    AbstractSkillImpact skillImpact = SkillHelper.createSkillImpact(impactLogicID, sender.getScene());

     //初始化buff时长，根据StandardImpact表里配置durationTimeSpecial时长
    skillImpact.init(sender.getObjectID(), receiver,impactData);
    ...

    //计算buff时长,其它修改引起修正
    skillImpact.calcBuffTime(receiver, sender);

    ...
    // 派发逻辑
    int receiveRS = receiver.getSkillModule().receivedImpact(skillImpact);

}
```
列举了些重要的处理，buff时长读表，派发逻辑receivedImpact

```java
/**
* 接收一个impact效果
*
* @param skillImpact
* @return
*/
public int receivedImpact(AbstractSkillImpact skillImpact)
{
    ...
     // 能否接受效果检测
    int canRs = canReceiveImpact(skillImpact);
    if(canRs < 0)
    {
        return canRs;
    }
    ...

    // 处理互斥
    int rs = dealImpactMutexAndRepeat(skillImpact);
    if (rs < 0)
    {
        return rs;
    }
    ...
}
```
能否接受效果检测,例如：之前上了一个增益类型的buff无敌，那么此时接收一个负面类的buff不通过。

处理互斥,走表配置。

```sh
1.非持续性不处理互斥。

2.来源于同一个单位的同一BUFF组的叠加规则：（可叠加的BUFF在层数满之后只刷新BUFF时间）
    0:替换，互斥优先级低的无法替换高级的
    1:刷新BUFF时间（刷新BUFF时间的效果不会充值周期触发效果的周期循环）
    2:添加不影响现有
    3:无法添加新BUFF
（前两种情况下，BUFF等级低于目标身上同组BUFF等级的无法生效）

3.不同源BUFF叠加规则:
    0:直接替换（低级BUFF不可替换高级的）
    1:刷新BUFF时间（同等级BUFF刷新BUFF时间，BUFF来源不变，高级的BUFF覆盖低级的，BUFF来源改为高级BUFF的施加者）
    2:各自添加不互相影响
```

![](/images/posts/mmo_game/13.jpg)
```sh
现在无敌buff配的是，互斥组配的是1也就是自身互斥，同源叠加规则配的是0，即替换。

那么假设同时给自身上两个无敌buff，第一个无敌buff直接被第二个无敌buff替换掉。

```

```java
/**
    * 处理BUFF的互斥
    * @param mutexType 互斥类型
    * @param buff      身上的BUFF
    * @param addImpact 要添加的BUFF效果
    * @return
    */
private int doMutexImpact(int mutexType,AbstractSkillImpact buff,AbstractSkillImpact addImpact)
{
    ...
    ...
     else
    {
        // 中断互斥顶替掉的buff
        buff.onBeMutexBreeak(getCharacter(),addImpact);
        buff.breakImpact(getCharacter());

        return 0;
    }
    ...
    ...
}
```
同时给自身上两个无敌buff，可以根据配置规则让第一个无敌buff直接被第二个无敌buff替换掉。

需要先调用breakImpact(AbstractCharacter character)中断第一个buff效果。

然后将新来的无敌buff添加到buff列表里。

## 技能系统图示

技能系统服务器客户端流程:

![](/images/posts/mmo_game/21.jpg)

技能系统控制流程抽象:

![](/images/posts/mmo_game/22.jpg)

## 技能释放流程

### 1.前端使用技能请求

```java
// 使用技能请求
message CSUseSkillRequest{//20300
	required int32 skillID = 1; // 技能id
	required int32 targetObjectID = 2; // 选择的目标id
	required int32 rotation = 3; // 朝向, 传0->360
	required int32 sign = 4; // 技能标识
	required int32 type = 5; // 类型:0玩家 1宠物 2傀儡 3侠客
	optional int32 dummyObjectID = 6; // 傀儡ObjectID(用于傀儡释放技能);当type为3时,该值为侠客的KnightID
	repeated int32 paths = 7; //x,y,z坐标结合(位移技能路径)
	repeated int32 hitPoints = 8; // x,y,z生效的打击点坐标集合(目前主要给侠客大招使用)
	optional bool isStandalone = 9; // 是否是单机释放技能(目前主要给侠客大招使用)
}
```

### 2.玩家技能释放

目前版本很多废弃了，例如：宠物、轻功，所以我们直接从玩家技能释放开始看。

```java
/**
* 玩家使用技能
*
* @param message
* @param response
* @param actor
* @param isStandalone 是否是单机释放
*/
private void acoterUseSkill(BPFight.CSUseSkillRequest message, BPFight.SCUseSkillResponse.Builder response,
                            Actor actor,boolean isManualMoveSkill, boolean isStandalone)
{
    ...
    ...
    //旧的目标
    int lastTargetID = actor.getAbstractCharacterCommonModule().getTargetObjectID();
    //旧的朝向
    int lastRotation = actor.getRotation();

    //技能id
    int skillID = message.getSkillID();
    //目标id
    int targetID = message.getTargetObjectID();
    //技能标识
    int skillSign = message.getSign();
    ...
    ...

    //检测是否坐骑，坐骑不能使用技能

    //检测变身后能否使用技能

    //检查移动状态能否使用技能

    //设置客户端上传的最新目标和朝向

    //调用useSkill
    result = actor.getSkillModule().useSkill(actor, skillID, skillSign, isStandalone, true);

    //设置技能使用响应客户端

    //技能使用事件

    //客户端使用技能成功广播
}
```

```java
/**
* 使用技能
*
* @param character 使用者
* @param skillID   技能id
* @param sign      技能标识(客户端释放时指定，服务器主动释放填-1,内部会自动生成)
* @param isStandalone 是否是单机释放
* @param cltUse    是否客户端释放
* @return
*/
public int useSkill(AbstractCharacter character, int skillID, int sign, boolean isStandalone, boolean cltUse)
{
    //检查当前场景能否使用技能

    //是否正在使用技能
    boolean isContinuityUse = isUsingSkill();

    //根据技能id获取，技能模板表、技能编辑表、技能数据表数据

    //根据技能模板表，检查是否释放被动技能错误
    if (!skillTemplate.isActive())
    {
        return BPErrorCodeEnum.SKILL_USE_PASSIVE_SKILL_USE_REPEAT;
    }

    // 获取技能组
    DictSkillGroupData skillGroup = null;
    if (skillTemplate.getSkillGroupType() > 0)
    {
        skillGroup = (DictSkillGroupData) DictSkillGroupData.getRecordById(skillTemplate.getSkillGroupType());
        if (skillGroup == null)
        {
            return BPErrorCodeEnum.SKILL_SKILL_GROUP_NOT_MATCH;
        }
    }

    // 如果当前正在使用技能
    if(isContinuityUse)
    {
        //如果当前正在使用技能，做一个临时缓存
        tempSkillInfo.copyFrom(skillInfo);
    }

    //设置当前技能释放的技能信息
    skillInfo.setSkillGroup(skillGroup);
    skillInfo.setSkillEditorData(skillEditorData);
    skillInfo.setSkillData(skillData);
    skillInfo.setSkillTemplate(skillTemplate);

    // 检测技能使用条件（传入是否客户端释放）
    // 检查cd、消耗、技能组和单体技能检测、位移、自身、目标。
    int result = checkUseSkill(cltUse);


}
```

检查当前场景能否使用技能。

根据技能id获取，技能模板表、技能编辑表、技能数据表数据。

根据技能模板表，检查是否释放被动技能错误。

根据技能模板表获取技能组。

如果当前正在使用技能，将当前使用的技能信息做一个临时缓存。

设置当前技能释放的技能信息。

检测技能使用条件（传入是否客户端释放）。检查cd、消耗、技能组和单体技能检测、位移、自身、目标。
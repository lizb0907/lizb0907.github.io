---
layout: post
title: buff系统
categories: Mmo-Game
description: buff系统
keywords: bufff，fightModule
---

战斗系统重构后-buff系统学习记录

**目录**

* TOC
{:toc}

## 表分析

### 1.由于之前的buff表列数过多，将buff表拆分

#### 1.buff基础表SkillImpactBase 主要是条件，类似如下：

```sh
1.死后是否保留该效果（0否、1是）

2.是否增益效果
    0：其他
    1：增益类
    2：负面类

3.跨场景是否消失（0否、1是）

4.下线是否消失（0否、1是）

5.开始移动时是否消失（0否、1是）

各种一大堆条件
```

#### 2.SkillImpactParam参数表，由于特定效果的参数列非常多，故单独拆分出一张表:

```sh
状态影响效果产生的几率也是配在这里。
```

## 向目标发送一个效果,主要用于非技能模块的效果发送

### 1.计算派发概率

#### 1.无成长

```java
 // 是否是无成长的效果
DictSkillImpactParamData dictSkillImpactParamData = impactToNoGrowthImpactMap.get(impactId);
if(dictSkillImpactParamData != null)
{
    return dictSkillImpactParamData.getAddImpactOdds();
}
```

```sh
1.无成长的，直接表里配置概率（根据状态state是否大于0判断），效果产生几率SkillImpactBase表里配置参数名为addImpactOdds

2.所有的非技能模块都是无成长的，例如：
   药品使用加buff
   任何奖励
   称号

3.注意目前陷阱派发走的是技能派发。
```

#### 2.有成长

```java
TLongIntHashMap stateLevelProbablityMap = impactOnStateLevelToProbablityMap.get(impactId);
if(CollectionUtils.isBlank(stateLevelProbablityMap))
{
    return 0;
}

int noEntryValue = stateLevelProbablityMap.getNoEntryValue();

boolean hasState = false;
int rs = 0;

// 此处遍历非常非常频繁，所以不用迭代器，掏出来map的内部数组进行遍历
byte[] _state = stateLevelMap._states;
int[] _set = stateLevelMap._set;

int size = stateLevelMap.size();

for (int i = 0, iSize = _state.length; i < iSize; i++)
{
    ...
}
```

效果ID -> 技能状态 -> 状态等级 -> 概率

技能状态和状态等级会影响派发概率。

这里遍历非常频繁，所以不用迭代器遍历，直接掏出数组进行遍历。

#### 3.属性修正概率

```java
// 实际概率=表中对目标概率+攻击者对应ID命中属性-被攻击者对应ID抵抗属性
targetProb = targetProb + enchanceValue - declineValue;
```
SkillImpactBase表里会配置，属性修正，例如:派生中毒添加 217号属性会影响概率命中

#### 4.随机概率

```java
 // 随机概率
if(targetProb < GameConstant.TEN_THOUSAND && RandomUtil.randomInt(GameConstant.TEN_THOUSAND) > targetProb)
{
    return BPErrorCodeEnum.SKILL_IMPACT_PROBABLITY_FAIL;
}
```

如果当前概率小于10000，并且从0~10000随机取一个整数值 大于 当前概率， 那么属性派发概率失败。

这里有疑问，像任务这种其它系统派发buff, 那表里配置的概率都是超过10000吗？不然的话，有几率buff派发不上？

一般这种其它模块buff，没有特定需求需要概率派发，数值配置的概率都会大于10000，保证能派发上。

相当于，不同模块派发的buff概率类型会不同。


### 2.判断能否施加效果

#### 1.普通判断

1.能否作用到死亡玩家身上

2.判断buff生效目标（玩家，npc,宠物，镜像，傀儡...）

3.判断目标细分类型
```sh
ALL(0,true,true),               //  所有               (友好 √   敌对 √ )
SELF(1,true,false),             //  仅自己             (友好 √   敌对 × )
ENEMY(2,false,true),            //  敌对方             (友好 ×   敌对 √ )
FRIENDLY_NO_ME(3,true,false),   //  友方(不包括自己)    (友好 √   敌对 × )
FRIENDLY(4,true,false),         //  友方(包括自己)      (友好 √   敌对 × )
```
#### 2.大招受创绑定，不能上效果

1.代表受创的效果类型ID集合(指策划认为的播放受创动画)，配置在GameCofig表里的beHitImpactTypeID列

```java
int[] beHitImpactTypeIDs = getBeHitImpactTypeID();
if(!CollectionUtils.isBlank(beHitImpactTypeIDs))
{
    for (int i = 0, iSize = beHitImpactTypeIDs.length; i < iSize; i++)
    {
        //index为表里配置的逻辑id索引，例如24&&30&&32&&33&&34&&35&&48
        int index = beHitImpactTypeIDs[i];
        if(index >= 0)
        {
            beHitImpactTypeSet[index] = true;
        }
    }
}
```

2.SkillImpactBase配置逻辑id参数名为logicID

3.如果当前处于大招绑定受创，那么不能上效果

```java
// 大招受创绑定
int beBeatLockBindSender = getBeBeatLockBindSender();
if(beBeatLockBindSender > 0)
{
    if(sender.getObjectID() != beBeatLockBindSender)
    {
        boolean flag = DictGameConfigData.isBeHitImpactType(impactData.getLogicID());
        if(flag)
        {
            return BPErrorCodeEnum.SKILL_CANNOT_IMPCAT_BE_HIT_BIND;
        }
    }
}
```

### 3.击退转换

1.如果SkillImpactBase表配置的是击退效果，那么SkillImpactParam不能配置成长。

```java
// 击退转换效果，目前写死
if(dictSkillImpactBase.getLogicID() == 24)
{
    if(!paramNoGrowthImpactSet.contains(dictSkillImpactBase.getId()))
    {
        checkOk &= false;
        BPLog.BP_LOGIC.error("【技能表加载错误】SkillImpactParam加载错误，SkillImpactBase表中配置的是击退效果，但是在SkillImpactParam出现了成长！ [param-id] {} [impactID] {}",dic.getId(),impactId);
        continue;
    }

    int transferID = dic.impactParams[10];
    if (transferID > 0)
    {

        beatMoveTransferMap.put(dic.getId(), transferID);
    }
}
```

如果SkillImpactBase表配置了逻辑id为24，需要将当前的效果转为对应的转换效果id(击退转换击飞)。

### 4.创建效果实例

#### 1.初始化技能效果缓存

1.AbstractScene场景基类下，init()方法

sceneCache.initSkillCache(dictSceneDefine);

2.初始化缓存的基数为，指定长的对象队列长度：
```sh
1. 每条线最大承载人数 + 20 缓存基数

2. 如果缓存基数 >= 10, 那么去1 /2 

3. 如果缓存基数小于1，那么缓存基数等于1
```

3.根据buff逻辑id,每个逻辑new一个ArrayDeque队列，加入缓存
```java
ObjectQueue objectQueue = new ObjectQueue(baseNumber, new CreateImpact000());
skillImpactCache.add(objectQueue);

objectQueue = new ObjectQueue(baseNumber, new CreateImpact001());
skillImpactCache.add(objectQueue);
```

#### 2.定长的队列设计

```java
/**
 * 定长的对象队列,设计初衷是为了技能逻辑.技能效果的对象缓存
 * 如果poll的时候池内为空,增新new一个,如果add的时候池已满
 * 则直接丢弃,等待垃圾回收
 * 非线程安全
 */
public class ObjectQueue <T extends Reusable>
{
    private ArrayDeque<T> queue;

    /**
     * 当前长度
     */
    private int size;

    /**
     * 总容量
     */
    private int capacity;

    /**
     * 对象实例化的方法
     */
    private CreateTemplateInstance<T> function;


    /**
     * 构造函数初始化，容量和模板
     * @param capacity
     * @param func 所有实例都需要实现该接口，buff效果实例也需要实现该接口
     */
    public ObjectQueue(int capacity, CreateTemplateInstance func)
    {
        queue = new ArrayDeque<>(capacity);
        size = 0;
        this.capacity = capacity;
        function = func;
    }

    public ObjectQueue(T[] t)
    {
        this.capacity = t.length;
        queue = new ArrayDeque<>(capacity);
        size = 0;
        for (int i = 0; i < capacity; i++)
        {
            size++;
            queue.addLast(t[i]);
        }
    }

    /**
     * 如果队列已经为空则新new一个对象，否则弹出，队列长度减1
     * @return
     */
    public T poll()
    {
        if (size == 0)
        {
            if (function == null)
            {
                return null;
            }
            else
            {
                //队列为空时则新new一个对象
                return function.createTemplateInstance();
            }
        }

        size--;
        return queue.poll();
    }

    /**
     * T extends Reusable
     *
     * 添加进来的对象T实现了Reusable接口
     *
     * T会统一调用clear()方法，各个对象在重新加入对象池时，
     *
     * 自己覆写clear()方法，先进行清除操作，再添加进来
     *
     * 队列长度增加
     * @param object
     */
    public void add(T object)
    {
        if (object == null)
        {
            return;
        }

        if (size < capacity)
        {
            //调用clear()方法，各个对象自己覆写方法
            object.clear();
            queue.addLast(object);
            size++;
        }
    }

}
```
1. 定长的对象队列,设计初衷是为了技能逻辑.技能效果的对象缓存，如果poll的时候池内为空,增新new一个,如果add的时候池已满

则直接丢弃,等待垃圾回收，非线程安全。

2.添加进来时需要先清除数据。

#### 3.根据效果逻辑id去池里拿技能效果实例

```java
// 创建效果实例
AbstractSkillImpact skillImpact = SkillHelper.createSkillImpact(impactData.getLogicID(), sender.getScene());
if (skillImpact == null)
{
    return BPErrorCodeEnum.SKILL_SKILL_IMPACT_ID_IS_NOT_EXISTED;
}
```
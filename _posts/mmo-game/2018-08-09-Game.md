---
layout: post
title: java游戏服务端开发日常
categories: mmo-game
description: 记录日常开发积累
keywords: java游戏服务端，mmo，game
---

主要是日常工作中关于java游戏服务器开发积累



**目录**

* TOC
{:toc}

## 生活技能开发积累


### 1.Collections.sort(list)方法时，如果list是不可修改的，将报不可操作错误

```java
public static void main( String[] args )
{
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    //将list变为不可修改
    List<Integer> unModifiableList = Collections.unmodifiableList(list);
    test(unModifiableList);
}

private static void test(List<Integer> list)
{
    //对不可修改的list进行排序，将报错
    Collections.sort(list);

    for (int v : list)
    {
        System.out.println(v);
    }
}
```
结果：
```java
Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.Collections$UnmodifiableList.sort(Collections.java:1331)
 at java.util.Collections.sort(Collections.java:141)
 at com.lzb.App.test(App.java:38)
 at com.lzb.App.main(App.java:32)
```

游戏开发:

```java
// 生活技能合成操作 (烹饪、制药、熔矿)
message CSAbilityComposeOperate {
    required int32 abilityId = 1; // 生活技能id
    optional int32 composeId = 2; // 配方id(制药、熔矿、烹饪)
    required int32 composeNum = 3; // 合成数量
    required int32 useItemType = 4; // 使用材料类型 1 先绑定后非绑 2 只绑定 3 只非绑
    required int32 panEditorId = 5; // 烹饪锅的id
    optional bool useOptionalItem = 6; // 是否使用高级材料
    repeated int32 cookItems = 7; // 烹饪消耗食材列表
}
```
用protobuf时，例如repeated int32 cookItems = 7，服务器接受时默认是一个不可修改的list, 
所以我们可以先将list转成可修改的list，然后再调用Collections.sort()给list排序，就不会报错了。

```java
//转为可修改的list，再调用sort方法
List<Integer> modifiableList = new ArrayList<>(unmodifiableList);
Collections.sort(modifiableList);
```

### 2.jdk原生HashMap在get的时候，如果键值对没匹配到，那么返回的是null值

```java
HashMap<String, Integer> map1 = new HashMap<>();
map1.put("lzb", 100);

HashMap<Integer, Integer> map2 = new HashMap<>();
map2.put(1, 1);

System.out.println(map1.get("swf"));
System.out.println(map2.get(2));
```
结果:
```java
null
null
```

项目使用的trov4j里的 TIntIntHashMap如果key值没匹配上，那么返回是0

```java
TIntIntHashMap map3 = new TIntIntHashMap();
map3.put(1, 1);
System.out.println(map3.get(2));
```
结果:
```java
0
```

### 3.多个id组合成匹配唯一id

实际场景：烹饪配方id由策划可配的食材道具id组成（数量为1~5），不同的道具id组合成唯一的一个配方id。
前端发来乱序的食材道具id列表，我们去匹配是否有符合的烹饪配方id，这个场景如何做到性能较好的实现？

![](/images/posts/mmo_game/1.png)

实现方案：

初始化处理数据表数据时，将每个烹饪配方需要的食材id列表按从小到大先排序，然后将食材id列表拼接成一个字符串，字符串作为HashMap的key，value则是对应的烹饪配方id。

前端发来乱序的道具食材id列表，同样先将食材id进行从小到大排序，然后拼接成字符串，以这个字符串，去HashMap里匹配是否有烹饪配方id。


### 4.采集读条广播动作增加玩家朝向

实际场景:当玩家开始读条进行采集时，玩家朝向可能是背对采集物的，所以需要服务调整好朝向并广播给周围玩家。
那么我们需要根据当前玩家坐标点（x, z）和采集物坐标点（x, z），准确计算朝向。那么该如何计算朝向？
```java
/** 面向某点 */
public void faceTo(int x,int z)
{
	if(this.x == x && this.z == z)
	{
		return;
	}
	setRotation(MapUtils.rotationBetweenPos(this.x,this.z, x, z));
}
```
分析：调用MapUtils.rotationBetweenPos(this.x,this.z, x, z)计算出朝向，直接set到当前场景对象

```java
/** 返回点1对于点0的角度 */
public static int rotationBetweenPos(float x0, float y0, float x1, float y1) 
{
	double d = Math.atan2(y1 - y0, x1 - x0);

	d = d / Math.PI * 180;

	return rotationCut((int) d);
}
```
分析：计算角度

```java
// 通用读条开始通知
message SCCommonStartStripe{
	required int32 stripeID = 1; //读条id,对应DictCommonStripe表中的id
	repeated int32 params = 2; // 服务器透传参数
	optional int32 objectId = 3; // 对象id
	optional int32 rotation = 4; // 朝向 0-360
}
```
分析:最后在广播协议中加上朝向参数即可同步到周围玩家

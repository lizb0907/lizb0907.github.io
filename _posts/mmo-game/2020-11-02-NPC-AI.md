---
layout: post
title: 怪物的AI策略
categories: Mmo-Game
description: 怪物AI设计实现基于状态机:休闲AI、战斗AI、脚本AI
keywords: AI，NPC, 状态机，脚本AI
---

怪物AI设计实现基于状态机:休闲AI、战斗AI、脚本AI

**目录**

* TOC
{:toc}

### 表设计

```sh
有几个思想很重要:

1.模板表Npc, 可以简单理解为类型表。

2.实例表Npc_Stub_Editor关联Npc模板表,每个实例有自己特性，例如：
  出生坐标，朝向，基础AI...

3.实例表有配置AI列，模板表也有默认AI列，如果实例表不配置，那么默认模板
  表AI。相反，则以实例表配置AI为主。
```

## Npc创建流程

### 1.初始化数据

#### 1.NpcCreateModule创建Npc对象

```java
private void toCreateObject(Npc npc, DictNpcData dictNpc, int teamLevel,int x,int y,int z,int rotation)
{
    ...
    //NPC初始化
    npc.init();
    npc.afterLoad();
    getScene().addBPObject(npc);

        //初始化怪物
    npc.afterInit();
    ...
}
```
NpcCreateModule创建Npc对象

#### 2.Npc类下初始化属性npc.init();

1.初始化坐标，朝向...

2.初始化NPC数据表相关数据
```sh
private void initDictNpcAttr()
{
    赋值：
    DictNpcStub_editorData实例表
    DictNpcData模板表
    DictNpcBattleData怪物战斗表
}
```

3.initForceAndInteract()初始化阵营和交互类型

4.resetNpcAttr（）设置npc属性（自适应等级！重要）
```sh
/**
* 设置NPC属性
*
* @param teamLevel 自适应等级（大于0 为自适应等级怪）
*/
public void resetNpcAttr(int teamLevel)
{
    1.如果接口传入怪物等级则以接口传入为准，否则以实例表
      配置的怪物等级为准，如果实例表没有配置怪物等级则以
      模板表怪物等级为准。
    2.怪物设置经验：
         a.如果NpcBattle配置了该级别的最大经验值字段maxExp，
           则根据（基础值、最大值、增幅)计算公式，设置经验。
         b.否则直接读NpcBattle配置的基础值。
    3.设置默认移动、姿态...
    4.根据等级属性系数类型和自适应等级获取属性组：
         a.NpcBattle配置了等级属性系数类型rateType
         b.int[] attrs = DictNpcLevelAttrData.getAttr(
           battleData.getRateType(), level)取出属性组
         c.NpcBattle和NpcLevelAttr根据公式计算属性
    5.根据NpcBattle添加固定属性
    6.补魔补蓝
    7.设置怪物伤害最小归属：
      由于抢怪判定，当玩家累计伤害超过该怪物的最大血万分比，则该怪物归属这个玩家
}

```

#### 3.将npc添加到场景里

NpcCreateMoudule下：

getScene().addBPObject(npc);


#### 4.NpcCreateMoudule下npc.afterInit();

1.初始化AI，initAi()

2.设置出生动画，派发无敌buff

3.根据NpcBirth表设置是否使用战斗姿态

## AI模块初始化

### 1.创建NpcAiModule

创建npc时，会在成员变量下直接new一个NpcAiModule
```sh
/**
* @param npc
*/
public NpcAiModule(Npc npc)
{
    super(npc);
    owner = npc;
    battleFsmManager = new NpcAIFsmManager(npc);
    idleAIManager = new NpcIdleAIManager(npc);
    aiSpecialControlParam = AISpeicalcontrolParamFactory.create();
    aiSpecialControlParam.init();
    extraAiLogic = new ExtraAiLogicModule(npc);
    subStrategys = new ArrayList<>(1);
    waittingAddStrategys = new ArrayList<>(1);
    waittingRemoveStrategys = new TIntArrayList(1);
}

创建数据结构战斗状态机，空闲状态机...
```


### 2.初始化AI
NpcCreateMoudule下npc.afterInit()，

```sh
/**
* ai模块初始化
*/
private void initAi()
{
    Npc模板表和Npc_Stub_Editor实例表都会配置基础AI和扩展AI
    ,实例表优先级高。
    1.初始化扩展AI
    2.初始化基础AI
}
```

```java
/** 初始化正常ai */
private void normalAiInit()
{
    //初始化空闲ai
    initIdleAi();

    if(owner.getNpcType() != NpcTypeEnum.FUNCTION)
    {
        //功能NPC不初始化
        initBattleFsmManager();
    }

    // 初始化拓展AI
    initExtraAi(owner);
}
```

### 3.空闲AI

#### 1.初始化空闲ai

![](/images/posts/mmo_game/npc_ai/1.jpg)

```sh
初始化空闲ai:
private void initIdleAi()
{
    //状态机初始化
    isIdle = true;

    //初始化空闲状态机
    idleAIManager.init(dictNpcCommonAi.getAiDatas());

    //初始化巡逻数据
    int patrolId = owner.getPatrolId();
    if(patrolId > 0)
    {
        patrolPath = DictNpcPatrolPathData.getDictNpcPatrolPathData(patrolId);
    }
}

dictNpcCommonAi.getAiDatas():
    NpcCommonAi表的idleIds字段配置空闲下状态id组，对应NpcIdleAiState表主键
```

```sh
初始化空闲状态机:NpcIdleAIManager
 idleAIManager.init(dictNpcCommonAi.getAiDatas());
    public void init(DictNpcIdleAiStateData[] aiStateData)
    {
        BPAiCache aiCache = npc.getScene().getAiCache();
        int length = aiStateData.length;
        this.aiStates = new IdleAiState[length];
        this.curStateIndex = length-1;

        //是否有条件为空的状态
        boolean conditionEmpty = false;
        //初始化条件
        conditions = new boolean[length][];
        for (int i = 0; i < length; i++)
        {
            DictNpcIdleAiStateData stateData = aiStateData[i];
            //从池里拿出一个状态(这里利用了对象池的技术)
            IdleAiState aiState = aiCache.getIdleAiState();
            //重新初始化状态数据
            aiState.init(npc,this, i, stateData);
            aiStates[i] = aiState;
            //根据状态 获取 条件组
            DictNpcIdleAiConditionData[] conditionArray = stateData.getConditionArray();
            int size = conditionArray.length;
            //迭代每个状态的条件组
            for (int j = 0; j < size; j++)
            {
                //一个条件
                DictNpcIdleAiConditionData data = conditionArray[j];
                //一个条件关联的事件枚举组(例如:温度变化超出范围、温度变化回归正常)
                AIEventEnum[] eventEnum = data.getConditionEnum().getEventEnum();
                if(eventEnum != null)
                {
                    for (int m = 0, n = eventEnum.length; m < n; m++)
                    {
                        AIEventEnum aiEventEnum = eventEnum[m];
                        TIntArrayList list = eventToCondition.get(aiEventEnum);
                        if (list == null)
                        {
                            list = new TIntArrayList();
                            eventToCondition.put(aiEventEnum, list);
                        }
                        list.add(i);
                        list.add(j);
                    }
                }
            }
            //有条件为空的，将检测标识设置为true
            if(size == 0 && i < length-1)
            {
                isDirty = true;
            }
        }
        if(curStateIndex >= 0)
        {
            //初始化第一个状态
            IdleAiState aiState = aiStates[curStateIndex];
            if(aiState.getAiAction(0) != null)
            {
                aiState.setCurActionIndex(0);
            }
        }
    }
```

```sh
Npc空闲状态IdleAiState初始化:
/**
* 初始化空闲状态
* @param owner 生物
* @param idleAIManager 状态机管理器
* @param stateIndex 状态索引
* @param stateData 状态表数据
*/
public void init(T owner,NpcIdleAIManager idleAIManager, int stateIndex, DictNpcIdleAiStateData stateData)
{
     //状态条件组
    DictNpcIdleAiConditionData[] conditionArray = stateData.getConditionArray();
    //进入条件组长度
    int length = conditionArray.length;
    conditions = new AbstractAiCondition[length];
    for (int i = 0; i < length; i++)
    {
        DictNpcIdleAiConditionData conditionData = conditionArray[i];
        //根据类型创建对应的条件
        conditions[i] = AiConditionFactory.getCheckCondition(conditionData.getConditionEnum());
        //添加触发器，每个条件会有一个类型，对应表里的type字段
        //根据type会创建对应trigger
        idleAIManager.addTrigger(stateIndex, i, conditionData);
    }

    BPAiCache aiCache = owner.getScene().getAiCache();
    //执行行为组
    DictNpcIdleAiActionData[] actionsArray = stateData.getActionsArray();
    //状态切换，执行行为 数量
    int capacity = actionsArray.length;
    length = actionsArray.length;
    //创建执行行为组
    actions = new AbstractAiAction[length];
    for (int i = 0; i < length; i++)
    {
        DictNpcIdleAiActionData actionData = actionsArray[i];
        //从池里拿出执行行为
        AbstractAiAction aiAction = aiCache.getAiAction(actionData.getType());
        //todo todo 可能要判下空
        //重新初始化行为数据
        aiAction.init(owner, stateData, actionData);
        actions[i] = aiAction;

        List compositeActions = aiAction.getCompositeActions();
        if(compositeActions != null)
        {
            capacity += compositeActions.size();
        }
    }
    //状态切换，执行行为 (已经执行过， 不再执行)
    changeActions = new AbstractAiAction[capacity];
    for (int i = 0,m = 0, size = actionsArray.length; i < size; i++)
    {
        DictNpcIdleAiActionData actionData = actionsArray[i].getChangeActionData();
        if(actionData != null)
        {
            AbstractAiAction aiAction = aiCache.getAiAction(actionData.getType());
            aiAction.init(owner, stateData, actionData);
            changeActions[m++] = aiAction;

            //复合状态处理
            List<AbstractAiAction> compositeActions = aiAction.getCompositeActions();
            if(compositeActions != null)
            {
                i++;
                for (int j = 0, s = compositeActions.size(); j < s; j++)
                {
                    AbstractAiAction action = compositeActions.get(i);
                    AbstractAiAction changeAction = aiCache.getAiAction(action.getActionData().getChangeActionData().getType());
                    changeAction.init(owner, stateData, actionData);
                    changeActions[m++] = changeAction;
                }
            }
        }
    }

}

运用到了对象池，可以再深入探究

1.根据类型创建对应的条件组
2.添加触发器
3.创建执行行为组
4.状态切换，执行行为 (已经执行过， 不再执行)
5.退出行为组
```

#### 2.类主要成员

```java
/**
* 空闲状态机管理器
*
/
public class NpcIdleAIManager
{
     private Npc npc;

    /**
     * 状态表格数据组
     * 后面的优先级最低
     */
    private IdleAiState[] aiStates;

    
    /**
     * 当前运行的状态索引
     *
     * （因为状态组是后面的优先级高，所以当前状态索引从length - 1开始）
     */
    private int curStateIndex;

     /**
     * 条件标志是否更新
     */
    private boolean isDirty;

    /**
     * 各个状态的条件状态
     *
     * 状态索引-->条件索引-->是否触发
     */
    private boolean[][] conditions;

     /**
     * 条件触发器
     */
    private List<AbstractAiConditionTrigger> triggers = new ArrayList<>();

    
    /**
     * key事件类型，value 关联的条件索引 (状态索引，条件索引) 一组
     */
    private EnumMap<AIEventEnum,TIntArrayList> eventToCondition = new EnumMap<>(AIEventEnum.class);
}
```
核心思想，状态机根据当前维护的状态索引，执行对应状态的行为。如果，条件达成，判断

是否切入下一个状态机。

eventToCondition事件組，接受外部过来的事件，当事件过来判断关联的条件状态是否满足，满足

则做相应变化。

```java
//抽象的ai条件触发器
public abstract class AbstractAiConditionTrigger
{
    protected NpcIdleAIManager idleAIManager;

    /**
     * 状态索引
     */
    protected int stateIndex;

    /**
     * 条件索引
     */
    protected int conditionIndex;

    public void tick(int interval)
    {
        tickCallback(interval);
    }


    public abstract void tickCallback(int interval);

    /**
     * 监听器的回调
     * @param param0
     * @param param1
     * @return
     */
    public void listenerCall(int param0, int param1)
    {
    }
}
```

```sh
条件触发器里主要是：
1.当前条件触发器属于哪个状态以及哪个条件索引。

2.有tick调用接口，但trigger本身并不进行tick,是由空闲状态管理者统一管理，
  这么做非常好，可以解决自身tick浪费性能问题。例如多条件的与关系，如果空
  闲状态管理者tick trigger列表的时候，有一个条件不满足则可以立即跳出，节
  省性能。目前当条件tirgger满足后，是将对应的二维数组状态标识置为true,空
  闲状态管理者通过检查二维数组判断当前状态下所有的条件是否都为true来判断是
  否进入该状态。

3.监听器的回调listenerCall，条件支持了外部事件改变状态，很好的设计，有
  必要。 
```

```java
/**
 * NPC空闲ai 状态数据
 */
public class IdleAiState<T extends AbstractCharacter> implements Reusable
{
    /**
     * 进入条件
     */
    private AbstractAiCondition[] conditions;

    /**
     * 执行行为
     */
    private AbstractAiAction[] actions;

    /**
     * 状态切换，执行行为 (已经执行过， 不再执行)
     */
    private AbstractAiAction[] changeActions;

    /**
     * 状态切换时,退出执行的行为id （一定执行）
     */
    private AbstractAiAction[] exitActions;

    /**
     * 当前运行行为索引
     */
    private int curActionIndex = -1;
}
```
进入该状态的条件组，执行行为组...

```java
//条件
public abstract class AbstractAiCondition<E extends AbstractCharacter>
{
     /**
     * 条件检查
     */
    public final boolean onAIEvent(E owner, AIEventEnum eventEnum,DictNpcIdleAiConditionData conditionData, int param0, int param1)
    {
        return toOnAIEvent(owner, eventEnum, conditionData,param0,param1);
    }

    /**
     * 检查逻辑
     * @param eventEnum
     * @param param0
     * @param param1
     */
    protected abstract boolean toOnAIEvent(E owner, AIEventEnum eventEnum,
                                           DictNpcIdleAiConditionData conditionData, int param0, int param1);

    /**
     * 行为执行完成，是否需要清空 条件标志
     */
    public boolean isClearMark()
    {
        return false;
    }

}
```
提供统一的外部触发事件接口，子类覆写检测条件是否达成。

该条件也是状态下的条件组成一部分，例如上功能和ConditionTrigger有重复，

后来确认后，最主要原因是因为AiCondition是单例，而AiConditionTrigger因为很多参数，没发做成

单例，所以单独出来的一个AiCondition概念。
```java
//行为
public abstract class AbstractAiAction<T extends AbstractCharacter> implements Reusable
{
      /**
     * 是否执行
     * 默认执行，若执行过，则不在执行
     */
    protected boolean isRun;

    /**
     * 当前行为是否完成
     */
    protected boolean isComplete;


    //执行行为
    public final void executeAiAction(IdleAiState idleAIState, int interval)
    {

    }

      /**
     * 打断行为
     */
    protected AbstractAiAction breakAction;


}
```
行为分为持续性行为和立即行为!! 如果当前状态被打断，则需要打断当前行为，当前行为需要做一些

事情（例如：移动那么需要停止），同时需要根据配置执行打断要做的行为。

```sh
总结:
大体就是上面几个类，可以把它们理解为组件，组件分为：
    状态机管理组件、状态组件、条件组件、行为组件。

状态机管理器：管理所有状态，同时注册所有事件。外部触发的事件，都是由状态机管理先接受然后派发
             到对应状态。
             状态机管理器下注册的事件目前有两种：ConditionTrigger和AiCondition。

状态：注册自己关心的事件，管理所有条件和行为。条件是ConditionTrigger和AiCondition都满足了才能
     切为当前状态。

事件：如果是会动态变化的事件，例如：天气,  这种的事件都是基于外部事件立即触发的，即使天气改变了
     也是外部立即触发过来，然后状态机管理器统一tick的时候，会检测条件在当前时刻是否满足，所以可
     以解决动态变化事件问题。
```

#### 3.空闲ai执行流程

![](/images/posts/mmo_game/npc_ai/2.png)

![](/images/posts/mmo_game/npc_ai/3.jpg)

```java
/**
* tick检查
*/
public void tick(int interval)
{

    //触发器
    if(!triggers.isEmpty())
    {
        for (int i = 0, size = triggers.size(); i < size; i++)
        {
            triggers.get(i).tick(interval);
        }
    }
    //先检测当前状态的条件，ai条件检查
    checkAiCondition();

    //则执行当前状态的行为
    IdleAiState aiState = getIdleAIState(this.curStateIndex);
    if(aiState != null)
    {
        aiState.executeAiAction(interval);
    }
}
```

```java
/**
* 检查各个状态条件是否满足
* 是否需要切换状态
*/
private void checkAiCondition()
{
    if(!isDirty)
    {
        return;
    }

    boolean result = false;
    //状态组的状态索引
    int index = 0;
    int curStateIndex = this.curStateIndex;
    first:
    //后面的优先级最低，所以前往后遍历
    for (int i = 0, size = curStateIndex; i <= size; i++)
    {
        boolean[] condition = conditions[i];
        //只有有一个条件不满足则会跳出到first点
        for (int j = 0, length = condition.length; j < length; j++)
        {
            if(!condition[j])
            {
                continue first;
            }
        }
        //一个状态下的所有条件达成则可以跳出，因为前面的优先级比较高
        result = true;
        index = i;
        break;
    }
    if(result)
    {
        //状态条件满足
        //（因为状态组是后面的优先级更低，所以当前状态索引从length - 1开始）
        if(index < curStateIndex)
        {
            //执行下一状态
            executeNextState(index);
        }
    }
    //所有条件不满足，并且当前不是初始状态，那么需要切换初始状态
    else if(curStateIndex != (aiStates.length-1))
    {
        //所有条件都未不满足，切换到第一个行为
        resetState();
    }
    isDirty = false;
}
```

```java
//则执行当前状态的行为
IdleAiState aiState = getIdleAIState(this.curStateIndex);
if(aiState != null)
{
    aiState.executeAiAction(interval);
}
```

### 4.战斗AI

### 5.脚本AI
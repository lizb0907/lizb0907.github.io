---
layout: post
title: 场景
categories: mmo-game
description: mmo游戏里的场景设计
keywords: scene，mmo，game
---

场景的设计在mmo游戏里是比较核心的内容,这部分是我老大写的，写的很不错，值得我们学习下。

**目录**

* TOC
{:toc}

## 场景一些基本概念
```sh
在我们的游戏里，场景是继承AbstractService类，这里的AbstractService是业务上使用的服务，服务会被线程池调用。
可以简单理解为每个AbstractService是单独的一个线程，线程在线程池里执行，每个场景由单独的线程去驱动。所以，我们
在业务上如果将一些变量放置到了场景上，需要特别注意不同场景下多线程可能引起的问题。
```

## 场景组和单一场景

### 一：场景组

#### 1.适用场景
```sh
组场景适合人数较少，tick执行时间较短的场景类型，经验值是小于10人的场景，比如：单人副本、组队副本等等。
人数多了场景tick时间会上去，那么按顺序执行场景组就会有较大延迟。
```
#### 2.场景组意义
```sh
AbstractSceneGroupService中存储了一个场景数组，当适用于组场景的场景启动后会将场景add到AbstractSceneGroupService中的场景数组，每个组场景中存放多少个场景是根据公式：100 / 单场景容纳人数来进行计算的。组场景的意义就在于减少了ProcessorPool中的service数量，直接的减少了线程的调度量，对CPU的利用率更高。
```

#### 3.场景组执行
```sh
AbstractSceneGroupService由于是继承于AbstractService的，所以它可以在ProcessoPool中被线程调度执行，AbstractSceneGroupService在执行tick时会按照数组顺序依次执行场景的tick。
```

```java
/**
 * 场景组service,管理一组场景的tick
 * 这一组场景tick是按照先后顺序进行tick的
 * 这里并没有处理每个个体的frame rate,processor在调用tick的时候
 * 是根据SceneGroup的frame rate调用的
 * Created by wangqiang on 2017/9/21.
 */
public abstract class AbstractSceneGroupService extends AbstractService
{
    /**
     * 存在该场景组下的所有场景数组
     */
    private ArrayList<AbstractSceneService> sceneServiceArray = new ArrayList<>();

    /**
     * 待加入的场景service队列
     */
    private LocklessList<AbstractSceneService> waitingAddService = new LocklessList<>();

    /**
     * 待删除的场景service队列
     */
    private LocklessList<AbstractSceneService> waitingRemoveService = new LocklessList<>();

    @Override
    public void tick(int interval)
    {
        while (true)
        {
            AbstractSceneService service = waitingAddService.pop();
            if (service != null)
            {
                service.active();
                
                sceneServiceArray.add(service);
            }
            else
            {
                break;
            }
        }

        int size = sceneServiceArray.size();
        if (size < 1)
        {
            return;
        }

        long start = System.currentTimeMillis();

        for (int i = 0; i < size; i++)
        {
            long end = System.currentTimeMillis();
            AbstractSceneService sceneService = sceneServiceArray.get(i);
            // tick时间需要处理一下,因为每个tick都是阻塞的,所以interval时间需要每次计算
            sceneService.tick0(interval + (int)(end - start));
        }

        while (true)
        {
            AbstractSceneService service = waitingRemoveService.pop();
            if (service != null)
            {
                service.inactive();
                sceneServiceArray.remove(service);
            }
            else
            {
                break;
            }
        }
    }

    代码省略
    ...
    ...
    ...
    
}
```
分析：单人副本，组队副本...适用于场景数组的场景会加入到waitingAddService，这样可以减少线程池中线程的数量。tick执行的时候，我们可以看到组场景确实是会按照数组顺序依次执行场景的tick。

### 二：单一场景

#### 1.适用场景
```sh
单一场景适合人数较多、tick执行时间较长的场景类型，比如：主城、野外。
```
#### 2.单一场景执行
```sh
当场景启动后将场景直接add到ProcessorPool中进行调度，在ProcessorPool中独占一条线程执行一次tick，tick完成后释放占用的线程，然后等待下一次继续独占线程执行tick。
```

## 场景初始化过程
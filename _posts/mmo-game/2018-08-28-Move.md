---
layout: post
title: 移动
categories: Mmo-Game
description: mmo游戏里移动的一些设计和思考
keywords: move，mmo，game
---

mmo游戏里移动的一些设计和思考

**目录**

* TOC
{:toc}

## 腾讯学院移动教程

### 1：游戏里的三个世界

![](/images/posts/mmo_game/6.jpg)

### 2：有哪些行为需要在三个世界之间进行同步？

1.移动

2.技能

3.聊天

### 3：移动（2d）实现方式

#### 一:用移动向量来实现移动同步

客户端和服务器以相同的向量在奔跑，所以它们的位置始终是相同的。

![](/images/posts/mmo_game/7.jpg)

##### 什么时候客户端需要同步到服务端：

玩家发生转向、变速、停止

##### 网络延迟高的时候会发生什么？

![](/images/posts/mmo_game/8.jpg)

##### 本地到服务器的延迟（也称为上行延迟）：

例如本地玩家突然转向，由于发生延迟，转向的移动向量还没来得及发往服务器，服务器还是以上一次移动向量在运行，如上图服务器虚线部分代表在这个延迟时间内移动的距离，移动完虚线的距离后又收到客户端发送的向上移动向量。这个时候怎么办？

主要两个方案：

1.回溯（也就是服务器之间拖拽）

客户端发送向上移动向量时，还会带POS值，然后服务器判断服务器玩家当前的POS值是否相等，不对的话，服务器拉回，在进行向上移动向量。

2.加固定时长

其实他不是按照这个移动向量一直往前走，而是固定的只会让他走比如0.5秒，走0.5秒之后，如果没有接下来的包来，那么这个人就会停下来，这样就会保证我们两个的位置始终相同。但是有缺点，本地世界不管有没有发生转向都需要定时上报我的移动包。


##### 服务器到第三方（下行延迟）

因为发生延迟，所以第三方同样是以之前的移动向量运行，同样上图第三方虚线代表延迟时间内走的路。问题来了，第三方是没有办法把这个人直接拉回到原来的Pos坐标的，否则看起来特别怪异！

那延迟收到移动包怎么解决：

1.运动补偿

第三方走到这里就走到这里了，也就是延迟时间内沿着虚线移动到当前位置不变，然后有个补偿过去，所以第三方时间的位置可能会和本地世界和服务器世界有些位置是不一样的，第三方世界采用加速方案，快速切换过去，在切换的过程中往往速度比实际快的多，其实是一个追赶的过程。

所以第三方时间的位置往往和服务器或者本地世界位置有一些偏差，我们有时候会发现，明明自己的客户端技能打中的那个人，但是对方却没有扣血，这就是由于第三方世界和服务器位置有些偏差,第三方世界需要追赶，所以路径有时候和它真实的路径不一样。

2.加固定时长

##### 如果在移动过程中发生丢包了会怎么样？

本地发送服务器移动包丢失了，服务器收到下一个移动包，下一个移动包的位置跟当前位置相差太多的话，我们服务器往往采用直接拒绝当前的这个移动包，同时下发一个我服务器的移动包告诉本地我的位置在哪，本地会直接将人拖拽到当前位置。

这就是为什么，我们在游戏有的时候跑着跑着突然被拉回去，就是这个原因。


#### 二:用路点表示法来实现移动同步，客户端和移动端都以相同的路径上的路点移动那么也能保证同步

![](/images/posts/mmo_game/9.jpg)

如上图，其实还需要一个当前的点，然后才是x1,y1。。。

##### 如何实现同步？

例如，当客户端走到x1和y1位置后，上行，发送包上行包到服务器，服务器收到一个上行包会加一个开始时间戳t1（也就是收到的时间记上去），然后，每隔一段时间（一般来说是0.5秒，间隔时间越短越精确）

计算行走记录，根据距离计算出在第几个折现上，按照比例计算出在该折现上的位置。

##### 发生网络延迟时如何处理？

![](/images/posts/mmo_game/10.jpg)

##### 上行延迟

路点是有一个终点的，如果发生网络延迟，它不会像向量同步那样一直走的，路点同步服务器如果遇到终点那么玩家就会停下来。

如果本地世界客户端当前的点跟服务器的点相差太大，那么服务器会拒绝请求，进行服务器拖拽。

如果说相差不大，一般服务器会有一个容忍的距离，在这个容忍的距离中，服务器将人的位置直接射到客户端上行的位置，然后沿着这条路径再走。

##### 下行延迟

采用运动补偿


#### 总结

以上，2d中的游戏大多采用上面两种方式。另外，在实际上往往没有这么多折点，上传的路点一般就两点，起点和终点。

### 4：移动（3d）实现方式

##### 简单说一下3d地形:

![](/images/posts/mmo_game/11.jpg)

##### 3d场景在服务器上是一个一个的格子,大多数游戏，客户端是3d但服务器一般是2d

##### Grid就是将地图从二维平面上划分为一系类50*50的网格

##### 体素-Voxel:

![](/images/posts/mmo_game/12.jpg)

以grid为单位自下往上做CT扫描，如果射线碰到阻挡物称为体素，每一个体素是用XY还有一个层来定位的

每个体素包含它在第几层，还有它上沿和下沿的高度也就是这个物体的厚度

行走的需要判断Grid与Grid之间高差和容纳判断

轻功只需要校验容纳判定

## 我们mmo游戏里移动设计概要

### 1.简单设计思路

#### 单点和点组

移动同步分为单点和点组两种协议，点组在客户端定点寻路用,单点为视野内无阻挡点击和摇杆移动用。


#### 移动贴墙

对于移动贴墙时，按策划意图，不做移动速度分量，保持原速绕墙。

主客户端面向墙壁，其他客户端面向自身移动方向，与客户端沟通后，客户端表示主客户端的部分由客户端组自行处理。

服务器可认为没有人物移动时还需区分移动朝向和面向不同这事儿。

#### 校验

摇杆移动时客户端预估一个大约2秒后的抵达位置发到服务器，包括阻挡也是客户端自行判定，服务器只做校验。

#### 修正

移动时客户端发当前坐标和朝向到服务器，朝向直接信客户端（如需可以有改变朝向协议），坐标如与服务器差距较大，则拉回服务器坐标。

如偏差不大，信客户端，并服务器赋值为客户端坐标，并记录修正向量，每次修正都做向量叠加，当该向量距离超限时，判定为客户端非法，按此距离与单位移动速度计算出额定移动时间，将此客户端原地定身该时间。(定身，解定，为特殊协议，与战斗定身buff无关)

### 2.疾跑

#### 1.只要玩家移动了，那么服务端就会尝试开启疾跑

```java
// 单位移动组消息
message CSUnitMove{//20200
	required int32 index = 1; //单位序号(0:主角,1:宠物,2:傀儡,3:运镖车)
	required int32 nowX = 2; //当前x坐标
	required int32 nowY = 3; //当前y坐标
	required int32 nowZ = 4; //当前z坐标
	repeated int32 values = 5; //x,y,z坐标依次
	optional int32 dummyObjectId = 6; // 傀儡移动专用:傀儡的ObjectId
	optional bool isSyncY = 7; // 是否同步y
	optional int32 targetDistance = 8; // 目标距离 （若此距离小于配置距离，本次寻路不疾跑）
	optional bool nearBlock = 9; // 顶着墙行走(true为顶着墙行走，保持跑步状态)
}
```
消息体

```java
/** 客户端移动到(组) */
private void doMoveToList(int nowX, int nowY, int nowZ, List<Integer> moveList, boolean syncY,boolean fallDown, int targetDistance,boolean isNearBlock)
{
    ...
    ...
    ...
    BPLog.BP_LOGIC.info("移动目标距离----:{}", targetDistance);
    if (targetDistance > 0 && targetDistance <= DictGameConfig.getFindPathNotGallopMaxDistance())
    {
        // 距离太近，疾跑关闭
        findPathCloseGallop = true;
    }
    else
    {
        if (findPathCloseGallop)
        {
            findPathCloseGallop = false;
        }
    }

    if(!isMoving())
    {
        //开始行走事件  尝试疾跑、移动是否打断技能和buff
        onStartMove(true);
    }
    ...
    ...
}
```
当移动目标距离targetDistance过近，那么关闭疾跑状态设置为true。

这里的targetDistance是直接点击地图寻路，才会有值。否则，通过轮盘单点移动客户端上发的targetDistance的值都为0。

onStartMove开始移动事件，调用尝试开启疾跑

```java
/**
* 尝试开启疾跑计时
* @return
*/
public boolean tryPrepareGallop(boolean checkMoveingState)
{
    // 距离太近，疾跑关闭
    if (findPathCloseGallop)
    {
        return false;
    }

    ...
    ...

    //开启疾跑倒计时时间，tick会计算时间是否到达
    this.gallopSwitchRemian = DictGameConfig.getGallopBootMillis();

	return true;
}
```
尝试开启疾跑计时

```java
@Override
public void tick(int delay)
{
    if(moveState == MoveStateEnum.STAND)
    {
        tickGallopOff(delay);
    }
    else if(moveState == MoveStateEnum.MOVING)
    {
        tickGallopStart(delay);
    }
}
```
MoveModule类下根据不同的状态进行tick疾跑关闭和开启检查,tick时间到达那么会进行疾跑的关闭或开启

```java
/** 疾跑开启检查 */
private void tickGallopStart(int delay)
{
    ...
    ...
    gallopSwitchRemian -= delay;
    if(gallopSwitchRemian < 0)
    {
        // 区域规划 禁止疾跑区域中不触发疾跑
        if (getCharacter().getScene().getSceneGirdModule().isGallopForbiddenArea(getCharacter().getX(), getCharacter().getZ()))
        {
            gallopSwitchRemian = 0;
            return ;
        }

        //时间到了，开启疾跑
        startGallop();
    }
    ...
    ...
}
```
这里开启检查，除了判断时间是否到达，还会根据后台地图信息判断当前区域是否可以疾跑。

```java
/**
* 开启疾跑
*/
public void startGallop()
{
    this.gallopSwitchRemian = -1;

    if(this.moveAttitudeEnum == MoveAttitudeEnum.GALLOP)
    {
        return;
    }

    //设置移动姿态为--疾跑
    changeMoveAttitude(MoveAttitudeEnum.GALLOP);
    //增加速度
    getCharacter().getAttributeLogic().addOneAttribute(AttributeTypeEnum.MOVE_SPEED_C, DictGameConfig.getGallopMoveSpeedCAdd());

}
```
开启疾跑需要设置移动姿态为疾跑，并且增加移动速度属性。关闭疾跑类型，设置其他移动姿态，减少速度。

#### 2.客户端向服务端发送停止协议

```java
// 单位停止消息
message CSUnitStop{//20202
	required int32 index = 1; //单位序号(0:主角,1:宠物,2:傀儡)
	required int32 nowX = 2; //当前x坐标
	required int32 nowY = 3; //当前y坐标
	required int32 nowZ = 4; //当前z坐标
	required int32 rotation = 5;//客户端朝向(0-360)
	optional int32 slideId = 6; // 滑行ID
	optional int32 dummyObjectId = 7; // 傀儡移动专用:傀儡的ObjectId
}
```
注意这里传滑行ID

```java
/** 客户端停止 */
public void clientStopMove(int nowX,int nowY,int nowZ,int rotation,int slideId, boolean noticeSelf)
{
    ...
    ...
    // 关闭疾跑
    offGallop();

    // 调用滑行停止逻辑
    stopMoveWithSlide(slideId, noticeSelf);
    ...
    ...

}
```
关闭疾跑，同时调用滑行停止逻辑。
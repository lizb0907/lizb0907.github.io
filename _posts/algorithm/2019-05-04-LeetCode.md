---
layout: post
title: leetcodet题解
categories: Algorithm
description: 本系列主要是关于leetcode上题解
keywords: leetcode, solve
---

练练leetcode上的题目，顺便学学英语。



**目录**

* TOC
{:toc}

## 数组


### 283. Move Zeroes
```sh
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Example:

Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.

给定一个数组，写一个函数将0元素移动到数组末尾，同时保持非0元素的位置不变。

思路:

给定一个下标变量k。然后判断当前数组位置下标的值是否为0，不为0和k位置数组值交换，然后k++。为0,不动，数组下标后移。
```

```java
public class MoveZeros_02 {
	public static void moveZeros_02(int[] arr){
		int k=0;
		for (int i=0;i<arr.length;i++){
			if (arr[i]!=0){
				swap(arr,i,k);
				k++;
			}
		}

	}

	public static void swap(int[] arr,int i,int j){
		int temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}

	public static void main(String[] args) {
		int[] arr={5,2,0,6,0,4,8,0};
		MoveZeros_02 mz=new MoveZeros_02();
		mz.moveZeros_02(arr);
		for (int items:arr){
			System.out.print(items);
		}
	}
}
```

### 239. 滑动窗口最大值
```sh
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。
滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

思路：

一.滑动窗口，其实就是两个下标(l 和 r)控制窗口里数量大小，其中l是左下边，r是右下标。
  l和r都是只能++不让--， r控制的是进入窗口的数字，l控制的是离开窗口的数字，l <= r。

二.返回滑动窗口的最大值：
  1.最简单暴力的方法，当然是直接遍历窗口里的数字进行比较。
  2.用一个双端队列：
    a.核心思想，维护所有可能成为最大值的数组索引的优先级队列！！!
    b.队列记录数组索引，存的是数组索引，但是比较的是数组里的值，队列从头部到尾部是用索引取数组对应值从大到小排序。
	c.窗口下标r增加让新进来的数从队列尾部进来。新进来的数当前索引最大，所以如果比较值还是最大，那么队列里其它元素都可以弹出，
	  其它索引没有机会成为最大了，只保留当前索引。如果新进来的数最小，那么直接添加到队列尾部，随着l增加有机会成为最大。
	  如果是一个中间值，那么把比它小的值的索引从队列弹出，加入到对应位置。
	d.l增加说明有元素出窗口，如果当前l的索引刚好是队列头部索引，那么队列头部元素出队列，出窗口了。
```

实现如下:
```java
public static void main(String[] args)
{
    int[] arr = new int[]{1, 9, 8, 3, 5, 2};
    int wl = 3;

    int[] windowMaxValues = getWindowMaxValues(arr, wl);
    if (null != windowMaxValues)
    {
        for (int i = 0, length = windowMaxValues.length; i < length; i++)
        {
            System.out.print(windowMaxValues[i] + " ");
        }
    }
}

public static int[] getWindowMaxValues(int[] nums, int k)
{
    if (null == nums || nums.length < k || k <= 0)
    {
        return null;
    }

    LinkedList<Integer> queue = new LinkedList<>();
    int length = nums.length;
    //举例规律会发现最多会有length - k + 1个窗口
    int[] maxValues = new int[length - k + 1];
    //用i和长度k来控制窗口的左下标和右下标
    for (int i = 0; i < length; i++)
    {
        //如果当前队列不为空，并且尾元素小于当前索引元素（用索引取对应数组值）
        while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i])
        {
            queue.pollLast();
        }
        //添加的是索引
        queue.addLast(i);

        //窗口出值，需要判断是否更新队列
        if (i - k >= 0 && !queue.isEmpty())
        {
            //如果当前出窗口的索引，刚好和队列头索引相等，出队列
            if (queue.peekFirst() == i - k)
            {
                queue.pollFirst();
            }
        }

        //窗口形成，需要获取当前窗口最大值
        if (i - k + 1 >= 0 && !queue.isEmpty())
        {
            maxValues[i - k + 1] = nums[queue.peekFirst()];
        }
    }

    return maxValues;
}
```


## 字符串




## 动态规划


